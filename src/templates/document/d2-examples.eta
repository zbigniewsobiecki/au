# D2 Diagram Pattern Examples

Use these patterns as reference when generating D2 diagrams in documentation.
Prefer the SysML-derived patterns below when the model contains the corresponding constructs.

---

## SysML Entity → D2 Entity Relationship Diagram

When the SysML model contains `item def ... :> BaseEntity` with attributes and
`connection def` with cardinality ends, generate an ERD using `sql_table` shapes.

```d2
User: {
  shape: sql_table
  id: uuid {constraint: primary_key}
  email: string
  name: string
  role: UserRole
  createdAt: timestamp
}

Project: {
  shape: sql_table
  id: uuid {constraint: primary_key}
  ownerId: uuid {constraint: foreign_key}
  title: string
  status: ProjectStatus
}

Task: {
  shape: sql_table
  id: uuid {constraint: primary_key}
  projectId: uuid {constraint: foreign_key}
  assigneeId: uuid {constraint: foreign_key}
  title: string
  priority: Priority
}

User <-> Project: "1 to many"
Project <-> Task: "1 to many"
User <-> Task: "assigned to"
```

**Key rules:**
- Use `shape: sql_table` for each entity
- Mark `id` fields with `{constraint: primary_key}`
- Mark foreign key fields (ending in `Id`) with `{constraint: foreign_key}`
- Use `<->` for bidirectional relationships with cardinality labels

---

## SysML State Machine → D2 State Diagram

When the SysML model contains `state def` with `transition first X then Y`,
generate a state diagram with colored fills.

```d2
direction: right

Pending: Pending {style.fill: "#e8f5e9"}
Processing: Processing {style.fill: "#fff3e0"}
Shipped: Shipped {style.fill: "#e3f2fd"}
Delivered: Delivered {style.fill: "#fce4ec"}
Cancelled: Cancelled {style.fill: "#f3e5f5"}

Pending -> Processing
Processing -> Shipped
Shipped -> Delivered
Pending -> Cancelled
Processing -> Cancelled
```

**Key rules:**
- Use `direction: right` for horizontal flow
- Assign a unique pastel fill color to each state
- Use arrow labels for transition triggers when available

---

## SysML Action Flow → D2 Flow Diagram

When the SysML model contains `action def` with `first...then` control flow
and `flow from...to` data flow, generate a directed flow diagram.

```d2
direction: down

request: {shape: parallelogram; "CreateUserRequest"}
validateInput: "Validate email format\nand password strength"
checkExistingEmail: "Verify email is\nnot already registered"
hashPassword: "Securely hash\nthe password"
createUser: "Persist user\nto database"
generateTokens: "Generate JWT\ntokens"
response: {shape: parallelogram; "UserResponse"}

request -> validateInput
validateInput -> checkExistingEmail
checkExistingEmail -> hashPassword
hashPassword -> createUser
createUser -> generateTokens
generateTokens -> response
```

**Key rules:**
- Use `direction: down` for vertical flow
- Use `shape: parallelogram` for input/output parameters
- Use doc comments as step labels (with `\n` for wrapping)
- Connect steps in the order defined by `first...then`

---

## SysML Module Hierarchy → D2 Architecture Diagram

When the SysML model contains `part def ... :> ServiceModule` with layers,
ports, and `connection` instances, generate a nested architecture diagram.

```d2
direction: down

Presentation: {
  ApiGateway: "Request routing and validation"
}

Service: {
  AuthModule: "Authentication and authorization"
  UserModule: "User management"
  OrderModule: "Order processing"
}

Data: {
  Database: {shape: cylinder; "PostgreSQL"}
  Cache: {shape: cylinder; "Redis"}
}

Presentation.ApiGateway -> Service.AuthModule: "auth"
Presentation.ApiGateway -> Service.UserModule: "users"
Service.OrderModule -> Data.Database: "queries"
Service.AuthModule -> Data.Cache: "sessions"
```

**Key rules:**
- Group modules by their `layer` attribute into D2 containers
- Use the module's `responsibility` attribute as the D2 label
- Show connections between modules using port relationships
- Use `shape: cylinder` for databases and caches

---

## Generic System Architecture Pattern

```d2
direction: down

Frontend: {
  shape: rectangle
  Web App
  Mobile App
}

Backend: {
  shape: rectangle
  API Gateway.shape: hexagon
  Service A
  Service B
  API Gateway -> Service A
  API Gateway -> Service B
}

Data: {
  Database.shape: cylinder
  Cache.shape: cylinder
  Queue.shape: queue
}

Frontend -> Backend.API Gateway: HTTPS
Backend.Service A -> Data.Database
Backend.Service B -> Data.Cache
Backend.Service A -> Data.Queue
```

## Event/Request Flow Pattern

```d2
direction: down

User.shape: person
User -> API: request

API -> CommandQueue: enqueue
CommandQueue.shape: queue

CommandQueue -> Handler: process
Handler -> EventStore: persist
EventStore.shape: cylinder

EventStore -> Projector: project
Projector -> ReadModel: update
ReadModel.shape: cylinder

ReadModel -> API: query
API -> User: response
```

## External Integration Pattern

```d2
direction: right

App.shape: rectangle
App: {
  API Server
  Worker
}

External: {
  Auth Provider.shape: cloud
  Payment Gateway.shape: cloud
  Email Service.shape: cloud
  Storage.shape: cloud
}

App.API Server -> External.Auth Provider: OAuth
App.API Server -> External.Payment Gateway: payments
App.Worker -> External.Email Service: notifications
App.API Server -> External.Storage: file uploads
```

## Deployment Architecture Pattern

```d2
direction: down

Users.shape: person

CDN.shape: cloud
CDN: Cloudflare

Compute: {
  Frontend.shape: rectangle
  Frontend: Static Site

  Backend.shape: rectangle
  Backend: API Server

  Workers.shape: rectangle
  Workers: Background Jobs
}

Data: {
  Primary DB.shape: cylinder
  Read Replica.shape: cylinder
  Cache.shape: cylinder
  Queue.shape: queue
}

Users -> CDN: HTTPS
CDN -> Compute.Frontend: static assets
CDN -> Compute.Backend: API requests

Compute.Backend -> Data.Primary DB: writes
Compute.Backend -> Data.Read Replica: reads
Compute.Backend -> Data.Cache: caching
Compute.Backend -> Data.Queue: jobs

Compute.Workers -> Data.Queue: consume
Compute.Workers -> Data.Primary DB: writes
```
