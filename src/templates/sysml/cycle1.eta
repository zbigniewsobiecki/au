## Task: Discovery & Context

**Goal**: Understand what kind of system this is and its boundaries

### Project Metadata (Pre-discovered)

<% if (it.metadata) { %>
**Name**: <%= it.metadata.name %>
**Type**: <%= it.metadata.projectType %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
**Architecture**: <%= it.metadata.architectureStyle %>
**Runtime**: <%= it.metadata.runtime || "unknown" %>

**Entry Points**:
<% for (const ep of it.metadata.entryPoints || []) { %>
- <%= ep %>
<% } %>

**External Dependencies**:
<% for (const dep of it.metadata.externalDependencies || []) { %>
- <%= dep.name %> (<%= dep.type %>): <%= dep.purpose %>
<% } %>

**Ports**:
<% for (const [port, enabled] of Object.entries(it.metadata.ports || {})) { %>
<% if (enabled) { %>- <%= port %><% } %>
<% } %>
<% } else { %>
*No metadata available - run ProjectMetaDiscover first*
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### ⚠️ CRITICAL SYNTAX ERRORS - CHECK BEFORE WRITING

**ERROR 1: Value After Definition Name**
```sysml
// WRONG - Cannot assign value to a 'def'!
requirement def FR001 :> Base = "source.ts" {
                             ^^^^^^^^^^^^ SYNTAX ERROR
}

// CORRECT - Values go INSIDE the body with :>>
requirement def FR001 :> Base {
    :>> source = "source.ts";
}
```

**ERROR 2: Combining 'attribute' with ':>>'**
```sysml
// WRONG
part x : Type {
    attribute :>> name = "value";  // NEVER combine these!
}

// CORRECT
part x : Type {
    :>> name = "value";
}
```

**ERROR 3: :>> Without Inheritance**
```sysml
// WRONG - No base type to redefine from!
requirement def FR001 {
    :>> id = "FR-001";  // ERROR: nothing to redefine!
}

// CORRECT - Either inherit OR use attribute
requirement def FR001 :> DiscoveredRequirement {  // Has base type
    :>> id = "FR-001";  // Now :>> works
}

// OR standalone with attribute
requirement def FR001 {
    attribute id : Identifier = "FR-001";  // Define attribute directly
}
```

### Your Tasks

1. **Read key files**:
   - README* for project description and purpose
   - Package manifest for dependencies
   - docker-compose* / Dockerfile* for external services
   - Config files for environment variables

2. **Extract requirements**:
   - Functional requirements from documentation
   - Non-functional requirements (performance, security, etc.)

3. **Infer business requirements from dependencies**:

   When reading package.json files, infer functional requirements from key dependencies:

   | Dependency | Inferred Capability |
   |------------|---------------------|
   | `bcryptjs`, `argon2` | User authentication with password hashing |
   | `jsonwebtoken`, `jose` | Token-based authentication (JWT) |
   | `multer`, `formidable` | File upload handling |
   | `pg`, `mysql2`, `mongodb` | Database persistence |
   | `express-validator`, `zod`, `joi` | Input validation |
   | `react-query`, `swr` | Server state management |
   | `zustand`, `redux` | Client state management |
   | `react-hook-form` | Form handling |
   | `stripe`, `paypal` | Payment processing |
   | `nodemailer`, `sendgrid` | Email sending |

   **Example**: If `apps/backend/package.json` has `bcryptjs` and `jsonwebtoken`:
   ```sysml
   @SourceFile { :>> path = "apps/backend/package.json"; }
   requirement def FR001 :> DiscoveredRequirement {
       :>> id = "FR-001";
       doc /* The system shall support user authentication with secure password hashing (bcryptjs) and JWT-based session management. */
   }
   ```

4. **Generate SysML**:

   **context/boundaries.sysml** - Update with discovered external systems:
   ```sysml
   package SystemContext {
       import SysMLPrimitives::*;

       doc /*System: {name} - {description} */

       // External dependencies
       @external
       part def ExternalDependency {
           attribute name : String;
           attribute purpose : String;
       }

       // Discovered external systems
       // NOTE: Use ':>>' alone to redefine attributes - NOT 'attribute :>>'!
       part database : ExternalDependency {
           :>> name = "{discovered}";    // CORRECT - no 'attribute' keyword
           :>> purpose = "Data persistence";
       }

       // System boundary
       part def System {
           // Discovered ports
           port httpApi [0..1];
           port grpcApi [0..1];
           port cliInterface [0..1];
       }

       part system : System;
   }
   ```

   **context/requirements.sysml** - Add discovered requirements:
   ```sysml
   package SystemRequirements {
       import SysMLPrimitives::*;

       doc /*Requirements extracted from {sources} */

       requirement def FR001 :> DiscoveredRequirement {
           :>> id = "FR-001";
           :>> source = "README.md";
           doc /*{requirement text} */
       }
   }
   ```

### Requirements: Standalone vs Inherited

**Standalone requirement (no base type):**
```sysml
requirement def FR001 {
    attribute id : Identifier = "FR-001";  // Define with value
    doc /* description */
}
```

**Inherited requirement (has base type):**
```sysml
requirement def FR001 :> DiscoveredRequirement {
    :>> id = "FR-001";                     // Redefine inherited attr
    doc /* description */
}
```

**ERROR - :>> without inheritance:**
```sysml
requirement def FR001 {          // No ":>"
    :>> id = "FR-001";           // WRONG! Use 'attribute id : T = v;'
}
```

**ERROR - value after definition name:**
```sysml
requirement def FR001 :> DiscoveredRequirement = "README.md" {  // WRONG!
    // Cannot assign value to a 'def' - values go INSIDE the body
}
// CORRECT:
requirement def FR001 :> DiscoveredRequirement {
    :>> source = "README.md";    // Value assigned to attribute inside body
}
```

### ID Sequencing Convention

**CRITICAL**: Before assigning any ID, use `SysMLRead` to check existing files and find the highest ID in use.

| Category | Format | Example |
|----------|--------|---------|
| Functional Requirements | FR-001, FR-002... | FR-001, FR-002, FR-003 |
| Security Requirements | SR-001, SR-002... | SR-001, SR-002 |
| Non-Functional Requirements | NFR-001, NFR-002... | NFR-001, NFR-002 |

- IDs must be sequential with no gaps
- Always continue from the highest existing ID
- Never reuse or reassign IDs

### What to Look For

- **Project purpose**: What problem does this solve?
- **External systems**: Databases, caches, message queues, APIs
- **Configuration surface**: Environment variables, config files
- **Entry points**: How is the system started/invoked?
- **Documented requirements**: README, docs/, CONTRIBUTING

### Deliverables

Write ONLY these files:
- `context/boundaries.sysml` - System context and external dependencies
- `context/requirements.sysml` - Discovered requirements

**IMPORTANT**: Do NOT write to any other directories (structure/, data/, behavior/, verification/, analysis/).
This cycle focuses ONLY on context and requirements. Data models, behavior, etc. will be handled in later cycles.

### CRITICAL: Coverage Tracking with @SourceFile

Coverage is calculated by scanning `@SourceFile { :>> path = "..."; }` metadata in your output.

**You MUST add @SourceFile metadata for EACH file from the "Files to Analyze" list above.**

For cycle 1, these are the specific files you must cover:
<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>` → requires `@SourceFile { :>> path = "<%= file %>"; }`
<% } %>
<% } %>

**Example - if analyzing package.json and turbo.json:**
```sysml
package SystemRequirements {
    import SysMLPrimitives::*;

    @SourceFile { :>> path = "package.json"; }
    requirement def FR001 :> DiscoveredRequirement {
        :>> id = "FR-001";
        doc /* Monorepo structure with workspaces defined in package.json */
    }

    @SourceFile { :>> path = "turbo.json"; }
    requirement def NFR001 :> DiscoveredRequirement {
        :>> id = "NFR-001";
        doc /* Build orchestration using Turborepo for parallel task execution */
    }
}
```

**IMPORTANT**: Coverage will be 0% if you annotate files NOT in the list above (e.g., annotating `vite.config.ts` when the list only contains `package.json`).

### STRICT FILE ADHERENCE

**CRITICAL**: You MUST ONLY add @SourceFile annotations for files listed in "Files to Analyze" above.

<% if (it.files && it.files.length > 0) { %>
**Files you CAN annotate** (from the list above):
<% for (const file of it.files.slice(0, 5)) { %>
- ✅ `<%= file %>`
<% } %>
<% if (it.files.length > 5) { %>
- ... and <%= it.files.length - 5 %> more from the list
<% } %>
<% } %>

**DO NOT** annotate files not in the list, even if you read them for context. If you discover useful information in other files, extract the insight but attribute the @SourceFile to the file from the list that led you there.

### Success Criteria

- [ ] SystemContext package has all external dependencies
- [ ] System boundary has correct ports (http, grpc, cli, etc.)
- [ ] Requirements package has at least basic functional requirements
- [ ] Documentation comments explain the system purpose
- [ ] Output is limited to `context/` directory only
- [ ] **Every file in "Files to Analyze" has at least one @SourceFile annotation**

<% if (it.isIterative) { %>
### File Selection Priority for Discovery

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. README files (`README.md`, `README.*`)
2. Package manifests (`package.json`, `Cargo.toml`, `go.mod`, `pyproject.toml`)
3. Docker files (`Dockerfile`, `docker-compose.yml`)
4. Config files (`.env.example`, `config/*`)
5. Documentation (`docs/*`, `CONTRIBUTING.md`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
