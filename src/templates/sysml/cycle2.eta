## Task: Structure & Modules

**Goal**: Map the codebase structure into SysML parts

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Architecture Style**: <%= it.metadata.architectureStyle %>
**Framework**: <%= it.metadata.framework || "none" %>
<% } %>

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**IMPORTANT**: Generate SysML definitions for content in files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `@SourceFile { path = "<filepath>"; }` metadata before each definition to track coverage.
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Analyze directory structure**:
   - Top-level directories and their purpose
   - Module boundaries and organization
   - Package/namespace hierarchy

2. **Identify architectural patterns**:
   - Layered (presentation/service/data)
   - Hexagonal (ports/adapters/domain)
   - Modular (feature-based organization)
   - Microservice boundaries

3. **Map module dependencies**:
   - Which modules depend on which
   - Entry points and routing
   - Dependency injection wiring

4. **Generate SysML**:

   **structure/_index.sysml** - Update architecture overview (MUST import all sibling packages):
   ```sysml
   package SystemArchitecture {
       import SysMLPrimitives::*;
       import SystemContext::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import SystemModules::*;
       import SystemInterfaces::*;
       import SystemConnections::*;

       doc /*Architecture: {style} */

       attribute architectureStyle : String = "{layered|hexagonal|modular}";

       // Module definition - extends Part for standard library compatibility
       part def Module :> Part {
           doc /*Base module - aligns with Parts::Part */
           attribute path : FilePath;
           attribute responsibility : String;
           attribute layer : String [0..1];
       }

       // Interface definition
       interface def ModuleInterface {
           attribute name : String;
           attribute methods : String [0..*];
       }
   }
   ```

   **⚠️ INDEX FILE WARNING**: The `_index.sysml` files accumulate imports over time.
   If modifying an existing index:
   1. First use `SysMLRead("structure/_index.sysml")` to see current content
   2. Then use search/replace mode to ADD new imports after existing ones
   3. Do NOT assume the file matches these examples - it may already have other imports

   **structure/modules.sysml** - Add discovered modules with ports:
   ```sysml
   package SystemModules {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;
       import SystemInterfaces::*;

       doc /*System module decomposition with typed ports */

       // Use specialization :> for module types
       // NOTE: Use ':>>' alone to redefine attributes - NOT 'attribute :>>'!
       part def AuthModule :> ServiceModule {
           doc /*Authentication and authorization module */
           :>> path = "src/auth";           // CORRECT - no 'attribute' keyword
           :>> responsibility = "Authentication and authorization";
           :>> layer = "service";

           // Typed port with directional items
           port authApi : AuthPort;
           port tokenEvents : EventPort;
       }

       part def UserModule :> ServiceModule {
           doc /*User management module */
           :>> path = "src/users";
           :>> responsibility = "User management";
           :>> layer = "service";

           port userApi : UserServicePort;
           port dbAccess : ~DataPort;  // Conjugated - consumes data
       }

       part def ApiGateway :> Module {
           doc /*API gateway and routing */
           :>> path = "src/api";
           :>> responsibility = "Request routing and validation";
           :>> layer = "presentation";

           // Client ports (conjugated to consume services)
           port authClient : ~AuthPort;
           port userClient : ~UserServicePort;
       }

       // Module instances
       part authModule : AuthModule;
       part userModule : UserModule;
       part apiGateway : ApiGateway;

       // Module connections (REQUIRED: 'connection' keyword!)
       connection apiToAuth connect apiGateway.authClient to authModule.authApi;
       connection apiToUser connect apiGateway.userClient to userModule.userApi;
   }
   ```

### Module Errors to Avoid

```sysml
// ERROR 1: attribute :>>
part def Bad :> ServiceModule {
    attribute :>> path = "x";    // WRONG!
}
// FIX: :>> path = "x";

// ERROR 2: :>> without inheritance
part def Standalone {            // No ":>"
    :>> path = "x";              // WRONG!
}
// FIX: attribute path : FilePath = "x";
```

   **structure/interfaces.sysml** - Define module interfaces with ports:
   ```sysml
   package SystemInterfaces {
       import SysMLPrimitives::*;

       doc /*Module interface definitions with typed ports */

       // Port definitions for module communication contracts
       // Use 'in item' and 'out item' for typed data flow
       port def AuthPort {
           doc /*Authentication service port */
           in item credentials : LoginRequest;
           out item tokens : TokenResponse;
           out item error : AuthError [0..1];
       }

       port def UserServicePort {
           doc /*User management service port */
           in item createUser : CreateUserRequest;
           in item updateUser : UpdateUserRequest;
           out item user : User;
           out item error : ServiceError [0..1];
       }

       port def DataPort {
           doc /*Generic data access port */
           in item query [0..*];
           out item results [0..*];
       }

       // Interface definitions connect provider and consumer ports
       interface def AuthInterface {
           doc /*Authentication contract between client and server */
           end provider : AuthPort;
           end consumer : ~AuthPort;  // Conjugated (directions flipped)
       }

       interface def ServiceInterface {
           doc /*Generic service contract */
           end server : ServicePort;
           end client : ~ServicePort;
       }
   }
   ```

   **structure/connections.sysml** - Inter-module wiring:
   ```sysml
   package SystemConnections {
       import SysMLPrimitives::*;
       import SystemModules::*;
       import SystemInterfaces::*;

       doc /*Module connections and wiring */

       // Named connection types
       connection def ServiceConnection {
           doc /*Service-to-service connection */
           end client;
           end server;
       }

       connection def DataConnection {
           doc /*Data access connection */
           end source;
           end target;
       }

       // Typed interface usage
       interface authContract : AuthInterface connect
           provider ::> authModule.authPort to
           consumer ::> apiModule.authClient;

       // Simple module connections
       connection userToDb : DataConnection
           connect userModule.dbPort to database.clientPort;

       connection apiToUser : ServiceConnection
           connect apiModule.userClient to userModule.api;
   }
   ```

### Patterns to Detect

**Layered Architecture**:
- `controllers/` or `routes/` → Presentation layer
- `services/` or `usecases/` → Business layer
- `repositories/` or `models/` → Data layer
- `utils/` or `lib/` → Shared utilities

**Hexagonal Architecture**:
- `domain/` → Core business logic
- `ports/` → Interface definitions
- `adapters/` → External implementations
- `application/` → Use cases

**Modular/Feature-based**:
- `features/` or `modules/` → Feature folders
- Each folder has own routes, services, models

### What to Look For

- **Module boundaries**: Clear separation of concerns
- **Public interfaces**: What each module exports
- **Internal details**: What is hidden within modules
- **Cross-cutting concerns**: Logging, auth, error handling

### Deliverables

Write ONLY these files:
- `structure/_index.sysml` - Architecture overview and module definitions
- `structure/modules.sysml` - Module decomposition with typed ports
- `structure/interfaces.sysml` - Port and interface definitions
- `structure/connections.sysml` - Inter-module connections and wiring

### Port and Interface Patterns

**Port Definition Pattern** - Define typed communication contracts:
```sysml
port def {Service}Port {
    in item {request} : {RequestType};
    out item {response} : {ResponseType};
    out item error : {ErrorType} [0..1];
}
```

**Interface Definition Pattern** - Connect provider and consumer:
```sysml
interface def {Service}Interface {
    end provider : {Service}Port;
    end consumer : ~{Service}Port;
}
```

**Module Specialization Pattern** - Inherit from base module types:
```sysml
part def {Name}Module :> ServiceModule {
    port api : {Service}Port;
    port db : ~DataPort;
}
```

**Connection Pattern** - Wire modules together:
```sysml
connection {name} connect {source}.{port} to {target}.{port};
```

**IMPORTANT**: Do NOT write to context/, data/, behavior/, verification/, or analysis/ directories.
This cycle focuses ONLY on architectural structure. Data models, behaviors, etc. will be handled in later cycles.

### Success Criteria

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
**Source File Coverage**:
- [ ] All files matching source patterns have been processed
- [ ] SysML definitions include `@SourceFile { path = "<filepath>"; }` metadata
<% } %>

- [ ] All major directories mapped to modules
- [ ] Architecture style correctly identified
- [ ] **Port definitions** created for each module's communication contract
- [ ] **Interface definitions** for inter-module contracts
- [ ] **Module specialization** hierarchies (`:>` from base types)
- [ ] **Connections** linking modules via ports
- [ ] Layer assignments are consistent
- [ ] Output is limited to `structure/` directory only

<% if (it.isIterative) { %>
### File Selection Priority for Structure Analysis

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Module entry points (`index.ts`, `index.js`, `mod.rs`, `__init__.py`)
2. Module files (`*.module.ts`, `*.module.js`)
3. Main/App files (`main.ts`, `app.ts`, `server.ts`)
4. Service definitions (`*.service.ts`, `*.service.js`)
5. Type definitions (`*.types.ts`, `*.interface.ts`)
6. Controllers (`*.controller.ts`, `*.handler.ts`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
