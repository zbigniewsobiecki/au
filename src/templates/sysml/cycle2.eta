## Task: Structure & Modules

**Goal**: Map the codebase structure into SysML parts

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Architecture Style**: <%= it.metadata.architectureStyle %>
**Framework**: <%= it.metadata.framework || "none" %>
<% } %>

### Type Definition Strategy

**Before writing ANY parts, decide what types you need:**

1. **Scan stdlib first** - Can you use `Module`, `Backend`, `Frontend`, `APIServer`?
2. **Define custom types** - Only if stdlib doesn't fit
3. **Then instantiate** - Create parts using your types

**Example workflow:**
```sysml
package SystemStructure {
    import SysMLPrimitives::*;

    // Step 1: Define custom types (if needed)
    part def ConfigModule :> Module {
        attribute configFormat : String;
    }

    // Step 2: Instantiate using types
    part eslintConfig : ConfigModule {
        :>> name = "eslint-config";
        :>> configFormat = "js";
    }

    part tsConfig : ConfigModule {
        :>> name = "typescript-config";
        :>> configFormat = "json";
    }
}
```

**WRONG - Using a part name as a type:**
```sysml
// If you defined this:
part eslintConfig : Module { :>> name = "eslint"; }

// You CANNOT do this:
part myLinter : eslintConfig;  // ERROR: eslintConfig is a part, not a type!

// CORRECT:
part myLinter : Module { :>> name = "my-eslint"; }
```

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**IMPORTANT**: Generate SysML definitions for content in files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `@SourceFile { :>> path = "<filepath>"; }` metadata before each definition to track coverage.
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Analyze directory structure**:
   - Top-level directories and their purpose
   - Module boundaries and organization
   - Package/namespace hierarchy

2. **Identify architectural patterns**:
   - Layered (presentation/service/data)
   - Hexagonal (ports/adapters/domain)
   - Modular (feature-based organization)
   - Microservice boundaries

3. **Map module dependencies**:
   - Which modules depend on which
   - Entry points and routing
   - Dependency injection wiring

4. **Generate SysML**:

   **structure/_index.sysml** - Update architecture overview (MUST import all sibling packages):
   ```sysml
   package SystemArchitecture {
       import SysMLPrimitives::*;
       import SystemContext::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import SystemModules::*;
       import SystemInterfaces::*;
       import SystemConnections::*;

       doc /*Architecture: {style} */

       attribute architectureStyle : String = "{layered|hexagonal|modular}";

       // Module definition - extends Part for standard library compatibility
       part def Module :> Part {
           doc /*Base module - aligns with Parts::Part */
           attribute path : FilePath;
           attribute responsibility : String;
           attribute layer : String [0..1];
       }

       // Interface definition
       interface def ModuleInterface {
           attribute name : String;
           attribute methods : String [0..*];
       }
   }
   ```

   **⚠️ INDEX FILE WARNING**: The `_index.sysml` files accumulate imports over time.
   If modifying an existing index:
   1. First use `SysMLQuery(select="SystemArchitecture::*")` to see current imports
   2. Then use SysMLWrite with `element` + `at` to upsert imports
   3. Do NOT assume the file matches these examples - it may already have other imports

   **structure/modules.sysml** - Add discovered modules with ports:
   ```sysml
   package SystemModules {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;
       import SystemInterfaces::*;

       doc /*System module decomposition with typed ports */

       // Use specialization :> for module types
       // NOTE: Use ':>>' alone to redefine attributes - NOT 'attribute :>>'!
       part def AuthModule :> ServiceModule {
           doc /*Authentication and authorization module */
           :>> path = "src/auth";           // CORRECT - no 'attribute' keyword
           :>> responsibility = "Authentication and authorization";
           :>> layer = "service";

           // Typed port with directional items
           port authApi : AuthPort;
           port tokenEvents : EventPort;
       }

       part def UserModule :> ServiceModule {
           doc /*User management module */
           :>> path = "src/users";
           :>> responsibility = "User management";
           :>> layer = "service";

           port userApi : UserServicePort;
           port dbAccess : ~DataPort;  // Conjugated - consumes data
       }

       part def ApiGateway :> Module {
           doc /*API gateway and routing */
           :>> path = "src/api";
           :>> responsibility = "Request routing and validation";
           :>> layer = "presentation";

           // Client ports (conjugated to consume services)
           port authClient : ~AuthPort;
           port userClient : ~UserServicePort;
       }

       // Module instances (direct children of package - use plain 'part name : Type')
       part authModule : AuthModule;
       part userModule : UserModule;
       part apiGateway : ApiGateway;

       // Module connections (REQUIRED: 'connection' keyword!)
       connection apiToAuth connect apiGateway.authClient to authModule.authApi;
       connection apiToUser connect apiGateway.userClient to userModule.userApi;
   }
   ```

### Module Errors to Avoid

```sysml
// ERROR 1: attribute :>>
part def Bad :> ServiceModule {
    attribute :>> path = "x";    // WRONG!
}
// FIX: :>> path = "x";

// ERROR 2: :>> without inheritance
part def Standalone {            // No ":>"
    :>> path = "x";              // WRONG!
}
// FIX: attribute path : FilePath = "x";

// ERROR 3: part :>> as direct child of package
package SystemModules {
    part :>> myModule : AuthModule;  // WRONG! Package has no parent type!
}
// FIX: part myModule : AuthModule;
// (part :>> is only valid inside a 'part def X :> Y' or 'part x : Type' body)
```

   **structure/interfaces.sysml** - Define module interfaces with ports:
   ```sysml
   package SystemInterfaces {
       import SysMLPrimitives::*;

       doc /*Module interface definitions with typed ports */

       // Port definitions for module communication contracts
       // Use 'in item' and 'out item' for typed data flow
       port def AuthPort {
           doc /*Authentication service port */
           in item credentials : LoginRequest;
           out item tokens : TokenResponse;
           out item error : AuthError [0..1];
       }

       port def UserServicePort {
           doc /*User management service port */
           in item createUser : CreateUserRequest;
           in item updateUser : UpdateUserRequest;
           out item user : User;
           out item error : ServiceError [0..1];
       }

       port def DataPort {
           doc /*Generic data access port */
           in item query [0..*];
           out item results [0..*];
       }

       // Interface definitions connect provider and consumer ports
       interface def AuthInterface {
           doc /*Authentication contract between client and server */
           end provider : AuthPort;
           end consumer : ~AuthPort;  // Conjugated (directions flipped)
       }

       interface def ServiceInterface {
           doc /*Generic service contract */
           end server : ServicePort;
           end client : ~ServicePort;
       }
   }
   ```

#### Item Flow Pattern (E2E Step 2)

Interfaces and connections should include **explicit item flows** showing what data crosses each boundary. This is Step 2 of the 3-step E2E flow pattern (Step 1: action flows in Cycle 4, Step 3: allocations in Cycle 6).

```sysml
// Interface with item flows — shows typed data paths between ends
interface def LoginInterface {
    doc /*E2E Step 2: Data paths for login feature */
    end client : ~AuthPort;
    end server : AuthPort;
    flow from client.credentials to server.credentials;
    flow from server.tokens to client.tokens;
}

// Connection with item flow — typed data crossing a connection
connection def APIDataFlow {
    doc /*Item flow: typed data crossing a service connection */
    end consumer;
    end provider;
    flow requestPayload : HTTPRequest from consumer to provider;
    flow responsePayload : HTTPResponse from provider to consumer;
}
```

**Key rules for item flows:**
- Use `flow from X to Y` inside `interface def` to show data crossing the interface
- Use `flow name : Type from X to Y` inside `connection def` for typed item flows
- Every multi-step user feature should have item flows on its interface (E2E Step 2)
- Cross-reference: Step 1 (action flows) in `behavior/operations.sysml` (Cycle 4), Step 3 (allocations) in `analysis/allocations.sysml` (Cycle 6)

   **structure/connections.sysml** - Inter-module wiring:
   ```sysml
   package SystemConnections {
       import SysMLPrimitives::*;
       import SystemModules::*;
       import SystemInterfaces::*;

       doc /*Module connections and wiring */

       // Named connection types
       connection def ServiceConnection {
           doc /*Service-to-service connection */
           end client;
           end server;
       }

       connection def DataConnection {
           doc /*Data access connection */
           end source;
           end target;
       }

       // Typed interface usage
       interface authContract : AuthInterface connect
           provider ::> authModule.authPort to
           consumer ::> apiModule.authClient;

       // Simple module connections
       connection userToDb : DataConnection
           connect userModule.dbPort to database.clientPort;

       connection apiToUser : ServiceConnection
           connect apiModule.userClient to userModule.api;
   }
   ```

### Patterns to Detect

**Layered Architecture**:
- `controllers/` or `routes/` → Presentation layer
- `services/` or `usecases/` → Business layer
- `repositories/` or `models/` → Data layer
- `utils/` or `lib/` → Shared utilities

**Hexagonal Architecture**:
- `domain/` → Core business logic
- `ports/` → Interface definitions
- `adapters/` → External implementations
- `application/` → Use cases

**Modular/Feature-based**:
- `features/` or `modules/` → Feature folders
- Each folder has own routes, services, models

### What to Look For

- **Module boundaries**: Clear separation of concerns
- **Public interfaces**: What each module exports
- **Internal details**: What is hidden within modules
- **Cross-cutting concerns**: Logging, auth, error handling

### Deliverables

Write ONLY these files:
- `structure/_index.sysml` - Architecture overview and module definitions
- `structure/modules.sysml` - Module decomposition with typed ports
- `structure/interfaces.sysml` - Port and interface definitions
- `structure/connections.sysml` - Inter-module connections and wiring

### Port and Interface Patterns

**Port Definition Pattern** - Define typed communication contracts:
```sysml
port def {Service}Port {
    in item {request} : {RequestType};
    out item {response} : {ResponseType};
    out item error : {ErrorType} [0..1];
}
```

**Interface Definition Pattern** - Connect provider and consumer:
```sysml
interface def {Service}Interface {
    end provider : {Service}Port;
    end consumer : ~{Service}Port;
}
```

**Module Specialization Pattern** - Inherit from base module types:
```sysml
part def {Name}Module :> ServiceModule {
    port api : {Service}Port;
    port db : ~DataPort;
}
```

**Connection Pattern** - Wire modules together:
```sysml
connection {name} connect {source}.{port} to {target}.{port};
```

### Connection Validation Rules

**CRITICAL: Port existence before connection wiring**

When creating connections in `structure/connections.sysml`:

1. **Verify both ports exist** - Before writing `connect A.portX to B.portY`, confirm:
   - `portX` is declared on module A's `part def`
   - `portY` is declared on module B's `part def`

2. **Create missing ports first** - If a connection needs a port that doesn't exist:
   - First, `SysMLWrite` the port definition to the module's `part def`
   - Then, create the connection

3. **NEVER reuse an unrelated port** - Each connection must use a dedicated, correctly-typed port:
   ```sysml
   // WRONG - reusing portX for a connection to a different module
   connection aToBilling connect gateway.portX to billingService.api;

   // CORRECT - add the correct port first, then connect
   // Step 1: Add the port to the module definition
   //   SysMLWrite(path="structure/modules.sysml",
   //     element="port billingClient : ~BillingPort;",
   //     at="SystemModules::Gateway")
   // Step 2: Create the connection using the new port
   connection aToBilling connect gateway.billingClient to billingService.api;
   ```

4. **Skip connections you can't validate** - If the source code doesn't show a direct dependency between two modules, don't create a connection just to fill a gap. Only create connections that reflect actual code-level dependencies (imports, injections, API calls).

**IMPORTANT**: Do NOT write to context/, data/, behavior/, verification/, or analysis/ directories.
This cycle focuses ONLY on architectural structure. Data models, behaviors, etc. will be handled in later cycles.

### Success Criteria

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
**Source File Coverage**:
- [ ] All files matching source patterns have been processed
- [ ] SysML definitions include `@SourceFile { :>> path = "<filepath>"; }` metadata
<% } %>

- [ ] All major directories mapped to modules
- [ ] Architecture style correctly identified
- [ ] **Port definitions** created for each module's communication contract
- [ ] **Interface definitions** for inter-module contracts
- [ ] **Module specialization** hierarchies (`:>` from base types)
- [ ] **Connections** linking modules via ports
- [ ] **Item flows** on interfaces/connections (`flow from X to Y` within interface/connection defs)
- [ ] Layer assignments are consistent
- [ ] Output is limited to `structure/` directory only

<% if (it.isIterative) { %>
### File Selection Priority for Structure Analysis

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Module entry points (`index.ts`, `index.js`, `mod.rs`, `__init__.py`)
2. Module files (`*.module.ts`, `*.module.js`)
3. Main/App files (`main.ts`, `app.ts`, `server.ts`)
4. Service definitions (`*.service.ts`, `*.service.js`)
5. Type definitions (`*.types.ts`, `*.interface.ts`)
6. Controllers (`*.controller.ts`, `*.handler.ts`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
