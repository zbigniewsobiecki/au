
---
## Turn <%= it.iteration %>/<%= it.maxIterations %> Progress

- Files read: **<%= it.readCount %>** / ~**<%= it.expectedCount %>**
<% const coveragePercent = it.docCoveragePercent ?? (it.expectedCount > 0 ? Math.round((it.readCount / it.expectedCount) * 100) : 100); %>
- Coverage: **<%= coveragePercent %>%** (files both read and documented)
<% const stallCount = it.writesWithoutCoverageIncrease ?? 0; %>
<% if (stallCount > 0) { %>
- **Stalled turns: <%= stallCount %>** (turns without coverage increase)
<% } %>

<% const hasSyntaxErrors = it.validationExitCode === 1; %>
<% const hasSemanticErrors = it.validationExitCode === 2; %>
<% const hasValidationWarnings = it.validationExitCode === 0 && it.validationOutput && it.validationOutput.includes('warning'); %>

<% if (hasSyntaxErrors) { %>

## STOP — Fix Syntax Errors Before Continuing

**Ingestion is paused.** You must resolve all syntax errors shown below before analyzing new files or writing new SysML definitions.

**Do not:**
- Request new file batches via `FileViewerNextFileSet`
- Write new SysML definitions for uncovered source files
- Analyze new source files

**Do:**
1. Use `SysMLRead` to inspect the file containing the error (use `SysMLList()` to find it)
2. Use `SysMLWrite` to fix the specific issues
3. Validation re-runs automatically after each write — check that errors decrease

Once all syntax errors are resolved, the next status update will show normal ingestion instructions and you can resume coverage work.

<% } %>

<% if (it.validationOutput && it.validationOutput.trim().length > 0) { %>
<% if (it.validationExitCode === 0) { %>
## Model Validation Warnings
<% } else if (it.validationExitCode === 1) { %>
## Model Validation Errors (syntax)
<% } else if (it.validationExitCode === 2) { %>
## Semantic Warnings (non-blocking)
<% } %>

```
<%= it.validationOutput.trim() %>
```

<% } %>

<%~ include("./partials/validation-actions", it) %>

<% if (hasSemanticErrors && !hasSyntaxErrors) { %>
## Semantic Errors (non-blocking)

These reference errors will resolve as you cover more files. **Continue coverage work** — do not stop to fix these.
If a specific error is easy to fix (wrong type name), fix it opportunistically during a write.

<% } %>

<% if (!hasSyntaxErrors) { %>
<% /* Only show exploration instructions when no syntax errors */ %>

<% const missingFiles = it.docMissingFiles ?? []; %>

<% if (stallCount >= 3) { %>
## CRITICAL — COVERAGE STALLED AT <%= coveragePercent %>%

You have gone **<%= stallCount %> turns** without increasing coverage. You are rewriting content for files that are ALREADY covered.

**STOP ALL CURRENT WORK.** You MUST ONLY process files from the missing list below.

1. Call `FileViewerNextFileSet` with ONLY these uncovered paths
2. Write SysML for ONLY the new files returned
3. Do NOT touch any existing SysML definitions

<% if (missingFiles.length > 0) { %>
### UNCOVERED FILES — Use These Paths in FileViewerNextFileSet

```
<% for (const file of missingFiles.slice(0, 12)) { %><%= file %>
<% } %>
```
<% if (missingFiles.length > 12) { %>
*(+<%= missingFiles.length - 12 %> more — request additional batches after processing these)*
<% } %>
<% } %>

<% } else if (stallCount >= 1) { %>
## COVERAGE STALLED — <%= stallCount %> turns without increase (<%= coveragePercent %>%)

You are rewriting SysML for files that are already covered. This does NOT increase coverage.

**STOP** rewriting existing definitions. Instead:
1. Call `FileViewerNextFileSet` with uncovered file paths listed below
2. Write SysML for the NEW files only
3. Each write MUST cover at least one file from the "Files Missing" list

<% if (missingFiles.length > 0) { %>
### Use These Paths in FileViewerNextFileSet

```
<% for (const file of missingFiles.slice(0, 10)) { %><%= file %>
<% } %>
```
<% if (missingFiles.length > 10) { %>
*(+<%= missingFiles.length - 10 %> more)*
<% } %>
<% } %>

<% } else { %>
<% /* Normal (non-stalled) flow */ %>

<% if (coveragePercent < 50) { %>
**COVERAGE TOO LOW** — Document more files with @SourceFile metadata!
<% } else if (coveragePercent < 80) { %>
Coverage acceptable but continue to improve.
<% } %>

<% if (missingFiles.length > 0) { %>
<%
  // Group missing files by top-level directory for easier FVNFS batching
  const dirGroups = {};
  for (const file of missingFiles) {
    const parts = file.split('/');
    const dir = parts.length > 2 ? parts.slice(0, 2).join('/') : parts[0];
    if (!dirGroups[dir]) dirGroups[dir] = [];
    dirGroups[dir].push(file);
  }
  const sortedDirs = Object.keys(dirGroups).sort((a, b) => dirGroups[b].length - dirGroups[a].length);
%>
### Files Missing @SourceFile Documentation (<%= missingFiles.length %> files)
<% for (const dir of sortedDirs.slice(0, 8)) { %>

**<%= dir %>/** (<%= dirGroups[dir].length %> files)
<% for (const file of dirGroups[dir].slice(0, 5)) { %>
- `<%= file %>`
<% } %>
<% if (dirGroups[dir].length > 5) { %>
  *... +<%= dirGroups[dir].length - 5 %> more in this directory*
<% } %>
<% } %>
<% if (sortedDirs.length > 8) { %>
*(+<%= sortedDirs.length - 8 %> more directories)*
<% } %>
<% } %>

## Required Actions

<% if (coveragePercent < 80) { %>
1. Request uncovered files with `FileViewerNextFileSet(paths="...")`
2. Write SysML with `@SourceFile { :>> path = "<filepath>"; }` metadata
3. Do NOT rewrite existing definitions — only cover new files

**DO NOT call `FileViewerNextFileSet(paths="")` until coverage >= 80%**
<% } else { %>
Coverage is good. You may finish if you've:
- Extracted all relevant SysML elements
- Included `@SourceFile { :>> path = "<filepath>"; }` metadata for each covered file
<% } %>

<% } %>

<%~ include("./partials/maximize-extraction", it) %>

<% } %>
