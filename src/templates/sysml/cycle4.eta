## Task: Behavior & Logic

**Goal**: Capture how the system processes requests and manages state

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
**Ports**: <%= Object.entries(it.metadata.ports || {}).filter(([,v]) => v).map(([k]) => k).join(", ") || "none" %>
<% } %>

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**IMPORTANT**: Generate SysML behavior definitions from ALL files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `@SourceFile { :>> path = "<filepath>"; }` metadata before each definition to track coverage.
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Find behavior sources**:
   - Controllers/handlers
   - Service methods
   - Use cases
   - Event handlers
   - CLI commands

2. **Map operations**:
   - Input/output for each operation
   - Steps in the flow
   - Side effects

3. **Identify state machines**:
   - Entity lifecycle states
   - Workflow states
   - Session states

4. **Document event flows**:
   - Events emitted
   - Events handled
   - Pub/sub patterns

5. **Discover API endpoints**:
   - Find how this codebase defines HTTP routes (varies by framework)
   - Map HTTP methods (GET, POST, PUT, DELETE, PATCH) to handlers
   - Capture path parameters, query parameters, request bodies
   - Document response types and error responses

   **Output file**: `behavior/endpoints.sysml`
   ```sysml
   package APIEndpoints {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /*HTTP API endpoints discovered from routes */

       // Use item def :> APIEndpoint to get method/path attributes from stdlib
       // This allows :>> redefinitions for method and path

       item def ListVehiclesEndpoint :> APIEndpoint {
           doc /* List vehicles with optional filtering */
           :>> method = HTTPMethod::GET;
           :>> path = "/api/vehicles";
           item filters : VehicleFilters [0..1];
           item response : Vehicle [0..*];
       }

       item def GetVehicleByIdEndpoint :> APIEndpoint {
           doc /* Get a single vehicle by ID */
           :>> method = HTTPMethod::GET;
           :>> path = "/api/vehicles/:id";
           :>> pathParams = ("id");
           item response : Vehicle;
       }

       item def CreateVehicleEndpoint :> APIEndpoint {
           doc /* Create a new vehicle */
           :>> method = HTTPMethod::POST;
           :>> path = "/api/vehicles";
           item request : CreateVehicleDto;
           item response : Vehicle;
       }

       item def HealthCheckEndpoint :> APIEndpoint {
           doc /* Health check endpoint - public, no auth required */
           :>> method = HTTPMethod::GET;
           :>> path = "/health";
           :>> requiresAuth = false;
           item response : HealthStatus;
       }

       item def LoginEndpoint :> APIEndpoint {
           doc /* User authentication endpoint */
           :>> method = HTTPMethod::POST;
           :>> path = "/auth/login";
           :>> requiresAuth = false;
           item request : LoginRequest;
           item response : AuthResponse;
       }
   }
   ```

   Search for route definitions specific to this codebase - look for framework patterns like:
   - Express: `app.get()`, `router.post()`, `app.use('/api', router)`
   - NestJS: `@Get()`, `@Post()`, `@Controller()` decorators
   - Fastify: `fastify.get()`, route registration
   - Flask: `@app.route()`, `@blueprint.route()`
   - Django: `path()`, `url()` patterns

6. **Discover analytics & aggregation methods**:
   - Find methods that summarize or aggregate data (not just CRUD)
   - Look for dashboard data sources
   - Find time-series aggregations (monthly, weekly, daily stats)

   Model these distinctly from basic CRUD operations:
   ```sysml
   action def GetSalesStats {
       doc /* Returns aggregated sales statistics */
       out totalSales : Integer;
       out totalRevenue : Real;
       out averageOrderValue : Real;
   }

   action def GetMonthlySalesStats {
       doc /* Aggregates sales by month for reporting dashboard */
       in year : Integer[0..1];
       out stats : MonthlyStat[*];
   }

   action def GetVehicleStats {
       doc /* Summary counts of vehicles by status */
       out available : Integer;
       out sold : Integer;
       out reserved : Integer;
   }
   ```

7. **Discover query & filtering patterns**:
   - Find filter types/interfaces with optional fields
   - Identify which entities support complex querying
   - Document pagination and sorting parameters

   ```sysml
   attribute def VehicleFilters {
       doc /*Filter options for vehicle search */
       attribute make : String[0..1];
       attribute model : String[0..1];
       attribute yearMin : Integer[0..1];
       attribute yearMax : Integer[0..1];
       attribute priceMin : Real[0..1];
       attribute priceMax : Real[0..1];
       attribute status : VehicleStatus[0..1];
       attribute condition : VehicleCondition[0..1];
       attribute search : String[0..1];
   }

   attribute def CustomerFilters {
       doc /*Filter options for customer search */
       attribute email : String[0..1];
       attribute phone : String[0..1];
       attribute search : String[0..1];
   }
   ```

8. **Generate SysML**:

   **behavior/_index.sysml** - Update overview (MUST import all sibling packages):
   ```sysml
   package SystemBehavior {
       import SysMLPrimitives::*;
       import DataModel::*;
       import SystemArchitecture::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import SystemOperations::*;
       import EntityStateMachines::*;
       import EventHandlers::*;

       doc /*System behavioral model */
   }
   ```

   **⚠️ INDEX FILE WARNING**: The `_index.sysml` files accumulate imports over time.
   If modifying an existing index:
   1. First use `SysMLRead("behavior/_index.sysml")` to see current content
   2. Then use SysMLWrite with `element` + `at` to upsert imports
   3. Do NOT assume the file matches these examples - it may already have other imports

   **behavior/operations.sysml** - Add operations with data flows:
   ```sysml
   package SystemOperations {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /*System operations/actions with explicit data flows */

       // User registration operation with full flow specification
       // Action bodies use 'first' for control flow (NOT 'transition'!)
       // Use 'flow from X to Y' for data flow between steps
       action def RegisterUser {
           doc /*Register a new user account */

           in request : CreateUserRequest;
           out response : UserResponse;
           out error : ErrorResponse [0..1];

           // Define action steps with typed inputs/outputs
           action validateInput {
               doc /*Validate email format and password strength */
               in data : CreateUserRequest;
               out validated : CreateUserRequest;
               out validationError : ValidationError [0..1];
           }

           action checkExistingEmail {
               doc /*Verify email is not already registered */
               in userData : CreateUserRequest;
               out checkedData : CreateUserRequest;
               out duplicateError : DuplicateError [0..1];
           }

           action hashPassword {
               doc /*Securely hash the password */
               in userData : CreateUserRequest;
               out securedData : SecuredUserData;
           }

           action createUser {
               doc /*Persist user to database */
               in data : SecuredUserData;
               out user : User;
           }

           action generateTokens {
               doc /*Generate JWT access and refresh tokens */
               in user : User;
               out tokens : TokenResponse;
           }

           // Explicit data flows between action steps
           flow from request to validateInput.data;
           flow from validateInput.validated to checkExistingEmail.userData;
           flow from checkExistingEmail.checkedData to hashPassword.userData;
           flow from hashPassword.securedData to createUser.data;
           flow from createUser.user to generateTokens.user;
           flow from generateTokens.tokens to response;

           // Error flows
           flow from validateInput.validationError to error;
           flow from checkExistingEmail.duplicateError to error;

           // Control flow sequencing
           first validateInput then checkExistingEmail;
           first checkExistingEmail then hashPassword;
           first hashPassword then createUser;
           first createUser then generateTokens;
       }

       // Authentication operation with flows
       action def Login {
           doc /*Authenticate user and issue tokens */

           in credentials : LoginRequest;
           out tokens : TokenResponse;
           out error : AuthError [0..1];

           action verifyCredentials {
               in creds : LoginRequest;
               out user : User;
               out authError : AuthError [0..1];
           }

           action checkAccountStatus {
               in user : User;
               out activeUser : User;
               out statusError : AccountStatusError [0..1];
           }

           action issueTokens {
               in user : User;
               out tokens : TokenResponse;
           }

           // Data flows
           flow from credentials to verifyCredentials.creds;
           flow from verifyCredentials.user to checkAccountStatus.user;
           flow from checkAccountStatus.activeUser to issueTokens.user;
           flow from issueTokens.tokens to tokens;

           // Error flows
           flow from verifyCredentials.authError to error;
           flow from checkAccountStatus.statusError to error;

           // Control flow
           first verifyCredentials then checkAccountStatus;
           first checkAccountStatus then issueTokens;
       }
   }
   ```

   **behavior/states.sysml** - Add state machines:
   ```sysml
   package EntityStateMachines {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /*Entity state machines */

       // Order lifecycle
       // State machines use 'transition first X then Y' keyword
       // In action bodies, use just 'first X then Y' instead
       state def OrderLifecycle {
           doc /*Order processing state machine */

           state Pending {
               doc /*Order created, awaiting processing */
           }

           state Processing {
               doc /*Order is being prepared */
           }

           state Shipped {
               doc /*Order has been shipped */
           }

           state Delivered {
               doc /*Order delivered to customer */
           }

           state Cancelled {
               doc /*Order was cancelled */
           }

           // Transitions: 'transition name? first Source then Target;'
           transition first Pending then Processing;
           transition first Processing then Shipped;
           transition first Shipped then Delivered;
           transition first Pending then Cancelled;
           transition first Processing then Cancelled;
       }

       // User session state
       state def SessionState {
           state Anonymous;
           state Authenticated;
           state Expired;

           transition first Anonymous then Authenticated;
           transition first Authenticated then Anonymous;
           transition first Authenticated then Expired;
           transition first Expired then Authenticated;
       }
   }
   ```

   **behavior/handlers.sysml** - Add event handlers:
   ```sysml
   package EventHandlers {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /*Event handlers */

       action def OnUserCreated {
           doc /*Handle user creation event */

           in event : UserCreatedEvent;

           action sendWelcomeEmail;
           action initializeUserSettings;
           action notifyAnalytics;

           // These can run in parallel
       }

       action def OnOrderShipped {
           doc /*Handle order shipped event */

           in event : OrderShippedEvent;

           action sendShippingNotification;
           action updateInventory;
       }
   }
   ```

### ID Sequencing Convention

**CRITICAL**: Before assigning any ID, use `SysMLRead` to check existing files and find the highest ID in use.

| Category | Format | Example |
|----------|--------|---------|
| Operations | OP-001, OP-002... | OP-001, OP-002 |
| State machines | SM-001, SM-002... | SM-001, SM-002 |
| Events | EV-001, EV-002... | EV-001, EV-002 |

- IDs must be sequential with no gaps
- Always continue from the highest existing ID
- Never reuse or reassign IDs

### Behavior Sources by Framework

| Framework | Behavior Sources |
|-----------|-----------------|
| Express/Fastify | Route handlers, middleware |
| NestJS | Controllers, services, guards |
| FastAPI | Route functions, dependencies |
| Django | Views, signals |
| Spring | Controllers, services |
| Gin/Echo | Handlers, middleware |

### Flow Patterns

**Data Flow Pattern** - Explicit data passing between action steps:
```sysml
action def {Operation} {
    in input : {InputType};
    out output : {OutputType};
    out error : {ErrorType} [0..1];

    action step1 {
        in data : {InputType};
        out result : {IntermediateType};
    }

    action step2 {
        in data : {IntermediateType};
        out result : {OutputType};
    }

    // Data flows
    flow from input to step1.data;
    flow from step1.result to step2.data;
    flow from step2.result to output;

    // Control flow
    first step1 then step2;
}
```

**Event Handler Pattern** - Port-based message handling:
```sysml
action def On{Event} {
    in event : {EventType};

    action process {
        in eventData : {EventType};
        out result : {ResultType};
    }

    action notify {
        in data : {ResultType};
    }

    flow from event to process.eventData;
    flow from process.result to notify.data;

    first process then notify;
}
```

**Parallel Flow Pattern** - Independent data paths:
```sysml
action def {Operation} {
    in input : {InputType};
    out output : {OutputType};

    // These actions can run in parallel
    action validateA { in data; out result; }
    action validateB { in data; out result; }

    action merge { in a; in b; out combined; }

    // Parallel flows
    flow from input to validateA.data;
    flow from input to validateB.data;
    flow from validateA.result to merge.a;
    flow from validateB.result to merge.b;
    flow from merge.combined to output;
}
```

**Compact E2E Action Flow Pattern (E2E Step 1)**

For key user-facing features, define a **compact E2E action flow** that captures the entire feature logic in one `action def`. This is Step 1 of the 3-step E2E flow pattern.

```sysml
// E2E Step 1: Compact action flow for login feature
action def LoginE2E {
    doc /*E2E login flow: validate → authenticate → issue tokens */
    in credentials; out tokens; out error [0..1];

    action validate  { in creds; out validCreds; }
    action authenticate { in validCreds; out user; out authError [0..1]; }
    action issueTokens { in user; out tokens; }

    // Data flows — full chain from input to output
    flow from credentials to validate.creds;
    flow from validate.validCreds to authenticate.validCreds;
    flow from authenticate.user to issueTokens.user;
    flow from issueTokens.tokens to tokens;

    // Error flows
    flow from authenticate.authError to error;

    // Control flow — explicit sequencing
    first validate then authenticate;
    first authenticate then issueTokens;
}
```

**Key rules for E2E action flows:**
- Name with `E2E` suffix to distinguish from simple operations (e.g., `LoginE2E`, `CheckoutE2E`)
- Include all sub-actions inline with typed `in`/`out` features
- Wire all data flows (`flow from`) and control flows (`first..then`) in one block
- Cross-reference: Step 2 in `structure/interfaces.sysml` (Cycle 2), Step 3 in `analysis/allocations.sysml` (Cycle 6)

### What to Look For

- **Happy path**: Normal operation flow with data transformations
- **Error handling**: Error outputs and flows from each step
- **Side effects**: External calls (email, payment, etc.)
- **Transactions**: Database transaction boundaries
- **Middleware**: Pre/post processing
- **Data transformations**: How data changes between steps
- **Route definitions**: How HTTP routes map to handlers (app.get, @Get, etc.)
- **Path parameters**: URL segments like `/vehicles/:id`
- **Query parameters**: Filter/sort/pagination params for list endpoints
- **Aggregation methods**: Methods named *Stats, *Summary, *Report, getMonthly*, getTotal*
- **Filter interfaces**: Types with optional fields for complex querying

### Deliverables

Write ONLY these files:
- `behavior/_index.sysml` - Behavior overview
- `behavior/operations.sysml` - System operations/actions with flows
- `behavior/states.sysml` - Entity state machines
- `behavior/handlers.sysml` - Event handlers (optional, if event-driven)
- `behavior/endpoints.sysml` - HTTP API endpoint definitions with routes, methods, params

**IMPORTANT**: Do NOT write to context/, structure/, data/, verification/, or analysis/ directories.
This cycle focuses ONLY on behavioral modeling. Verification and analysis will be handled in later cycles.

### Success Criteria

- [ ] All major operations captured with typed inputs/outputs
- [ ] **Data flows** (`flow from X to Y`) between action steps
- [ ] **Control flows** (`first X then Y`) for sequencing
- [ ] **Error flows** for error handling paths
- [ ] Entity state machines with proper transitions
- [ ] Event handlers with port-based flows (if applicable)
- [ ] **API endpoints** documented with HTTP methods and paths in `behavior/endpoints.sysml`
- [ ] **Query parameters** and filter types documented for list endpoints
- [ ] **Analytics/aggregation methods** captured (getStats, getMonthly*, getSummary)
- [ ] **Filter interfaces** documented for entities with complex querying
- [ ] Key user-facing features have **compact E2E action flows** (LoginE2E pattern)
- [ ] Side effects marked clearly
- [ ] Output is limited to `behavior/` directory only

<% if (it.isIterative) { %>
### File Selection Priority for Behavior Analysis

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Service files (`*.service.ts`, `*.service.js`)
2. Controller files (`*.controller.ts`, `*.handler.ts`)
3. Route files (`*.routes.ts`, `routes/*.ts`)
4. Use case files (`*.usecase.ts`, `usecases/*.ts`)
5. Event handlers (`*.handler.ts`, `handlers/*.ts`)
6. Middleware files (`*.middleware.ts`, `middleware/*.ts`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
