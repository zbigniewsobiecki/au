## Task: Behavior & Logic

**Goal**: Capture how the system processes requests and manages state

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
**Ports**: <%= Object.entries(it.metadata.ports || {}).filter(([,v]) => v).map(([k]) => k).join(", ") || "none" %>
<% } %>

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**IMPORTANT**: Generate SysML behavior definitions from ALL files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `// Source: <filepath>` comments to track which files have been covered.
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Find behavior sources**:
   - Controllers/handlers
   - Service methods
   - Use cases
   - Event handlers
   - CLI commands

2. **Map operations**:
   - Input/output for each operation
   - Steps in the flow
   - Side effects

3. **Identify state machines**:
   - Entity lifecycle states
   - Workflow states
   - Session states

4. **Document event flows**:
   - Events emitted
   - Events handled
   - Pub/sub patterns

5. **Generate SysML**:

   **behavior/_index.sysml** - Update overview (MUST import all sibling packages):
   ```sysml
   package SystemBehavior {
       import SysMLPrimitives::*;
       import DataModel::*;
       import SystemArchitecture::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import SystemOperations::*;
       import EntityStateMachines::*;
       import EventHandlers::*;

       doc /**System behavioral model */
   }
   ```

   **⚠️ INDEX FILE WARNING**: The `_index.sysml` files accumulate imports over time.
   If modifying an existing index:
   1. First use `SysMLRead("behavior/_index.sysml")` to see current content
   2. Then use search/replace mode to ADD new imports after existing ones
   3. Do NOT assume the file matches these examples - it may already have other imports

   **behavior/operations.sysml** - Add operations with data flows:
   ```sysml
   package SystemOperations {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**System operations/actions with explicit data flows */

       // User registration operation with full flow specification
       // Action bodies use 'first' for control flow (NOT 'transition'!)
       // Use 'flow from X to Y' for data flow between steps
       action def RegisterUser {
           doc /**Register a new user account */

           in request : CreateUserRequest;
           out response : UserResponse;
           out error : ErrorResponse [0..1];

           // Define action steps with typed inputs/outputs
           action validateInput {
               doc /**Validate email format and password strength */
               in data : CreateUserRequest;
               out validated : CreateUserRequest;
               out validationError : ValidationError [0..1];
           }

           action checkExistingEmail {
               doc /**Verify email is not already registered */
               in userData : CreateUserRequest;
               out checkedData : CreateUserRequest;
               out duplicateError : DuplicateError [0..1];
           }

           action hashPassword {
               doc /**Securely hash the password */
               in userData : CreateUserRequest;
               out securedData : SecuredUserData;
           }

           action createUser {
               doc /**Persist user to database */
               in data : SecuredUserData;
               out user : User;
           }

           action generateTokens {
               doc /**Generate JWT access and refresh tokens */
               in user : User;
               out tokens : TokenResponse;
           }

           // Explicit data flows between action steps
           flow from request to validateInput.data;
           flow from validateInput.validated to checkExistingEmail.userData;
           flow from checkExistingEmail.checkedData to hashPassword.userData;
           flow from hashPassword.securedData to createUser.data;
           flow from createUser.user to generateTokens.user;
           flow from generateTokens.tokens to response;

           // Error flows
           flow from validateInput.validationError to error;
           flow from checkExistingEmail.duplicateError to error;

           // Control flow sequencing
           first validateInput then checkExistingEmail;
           first checkExistingEmail then hashPassword;
           first hashPassword then createUser;
           first createUser then generateTokens;
       }

       // Authentication operation with flows
       action def Login {
           doc /**Authenticate user and issue tokens */

           in credentials : LoginRequest;
           out tokens : TokenResponse;
           out error : AuthError [0..1];

           action verifyCredentials {
               in creds : LoginRequest;
               out user : User;
               out authError : AuthError [0..1];
           }

           action checkAccountStatus {
               in user : User;
               out activeUser : User;
               out statusError : AccountStatusError [0..1];
           }

           action issueTokens {
               in user : User;
               out tokens : TokenResponse;
           }

           // Data flows
           flow from credentials to verifyCredentials.creds;
           flow from verifyCredentials.user to checkAccountStatus.user;
           flow from checkAccountStatus.activeUser to issueTokens.user;
           flow from issueTokens.tokens to tokens;

           // Error flows
           flow from verifyCredentials.authError to error;
           flow from checkAccountStatus.statusError to error;

           // Control flow
           first verifyCredentials then checkAccountStatus;
           first checkAccountStatus then issueTokens;
       }
   }
   ```

   **behavior/states.sysml** - Add state machines:
   ```sysml
   package EntityStateMachines {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**Entity state machines */

       // Order lifecycle
       // State machines use 'transition first X then Y' keyword
       // In action bodies, use just 'first X then Y' instead
       state def OrderLifecycle {
           doc /**Order processing state machine */

           state Pending {
               doc /**Order created, awaiting processing */
           }

           state Processing {
               doc /**Order is being prepared */
           }

           state Shipped {
               doc /**Order has been shipped */
           }

           state Delivered {
               doc /**Order delivered to customer */
           }

           state Cancelled {
               doc /**Order was cancelled */
           }

           // Transitions: 'transition name? first Source then Target;'
           transition first Pending then Processing;
           transition first Processing then Shipped;
           transition first Shipped then Delivered;
           transition first Pending then Cancelled;
           transition first Processing then Cancelled;
       }

       // User session state
       state def SessionState {
           state Anonymous;
           state Authenticated;
           state Expired;

           transition first Anonymous then Authenticated;
           transition first Authenticated then Anonymous;
           transition first Authenticated then Expired;
           transition first Expired then Authenticated;
       }
   }
   ```

   **behavior/handlers.sysml** - Add event handlers:
   ```sysml
   package EventHandlers {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**Event handlers */

       action def OnUserCreated {
           doc /**Handle user creation event */

           in event : UserCreatedEvent;

           action sendWelcomeEmail;
           action initializeUserSettings;
           action notifyAnalytics;

           // These can run in parallel
       }

       action def OnOrderShipped {
           doc /**Handle order shipped event */

           in event : OrderShippedEvent;

           action sendShippingNotification;
           action updateInventory;
       }
   }
   ```

### ID Sequencing Convention

**CRITICAL**: Before assigning any ID, use `SysMLRead` to check existing files and find the highest ID in use.

| Category | Format | Example |
|----------|--------|---------|
| Operations | OP-001, OP-002... | OP-001, OP-002 |
| State machines | SM-001, SM-002... | SM-001, SM-002 |
| Events | EV-001, EV-002... | EV-001, EV-002 |

- IDs must be sequential with no gaps
- Always continue from the highest existing ID
- Never reuse or reassign IDs

### Behavior Sources by Framework

| Framework | Behavior Sources |
|-----------|-----------------|
| Express/Fastify | Route handlers, middleware |
| NestJS | Controllers, services, guards |
| FastAPI | Route functions, dependencies |
| Django | Views, signals |
| Spring | Controllers, services |
| Gin/Echo | Handlers, middleware |

### Flow Patterns

**Data Flow Pattern** - Explicit data passing between action steps:
```sysml
action def {Operation} {
    in input : {InputType};
    out output : {OutputType};
    out error : {ErrorType} [0..1];

    action step1 {
        in data : {InputType};
        out result : {IntermediateType};
    }

    action step2 {
        in data : {IntermediateType};
        out result : {OutputType};
    }

    // Data flows
    flow from input to step1.data;
    flow from step1.result to step2.data;
    flow from step2.result to output;

    // Control flow
    first step1 then step2;
}
```

**Event Handler Pattern** - Port-based message handling:
```sysml
action def On{Event} {
    in event : {EventType};

    action process {
        in eventData : {EventType};
        out result : {ResultType};
    }

    action notify {
        in data : {ResultType};
    }

    flow from event to process.eventData;
    flow from process.result to notify.data;

    first process then notify;
}
```

**Parallel Flow Pattern** - Independent data paths:
```sysml
action def {Operation} {
    in input : {InputType};
    out output : {OutputType};

    // These actions can run in parallel
    action validateA { in data; out result; }
    action validateB { in data; out result; }

    action merge { in a; in b; out combined; }

    // Parallel flows
    flow from input to validateA.data;
    flow from input to validateB.data;
    flow from validateA.result to merge.a;
    flow from validateB.result to merge.b;
    flow from merge.combined to output;
}
```

### What to Look For

- **Happy path**: Normal operation flow with data transformations
- **Error handling**: Error outputs and flows from each step
- **Side effects**: External calls (email, payment, etc.)
- **Transactions**: Database transaction boundaries
- **Middleware**: Pre/post processing
- **Data transformations**: How data changes between steps

### Deliverables

Write ONLY these files:
- `behavior/_index.sysml` - Behavior overview
- `behavior/operations.sysml` - System operations/actions with flows
- `behavior/states.sysml` - Entity state machines
- `behavior/handlers.sysml` - Event handlers (optional, if event-driven)

**IMPORTANT**: Do NOT write to context/, structure/, data/, verification/, or analysis/ directories.
This cycle focuses ONLY on behavioral modeling. Verification and analysis will be handled in later cycles.

### Success Criteria

- [ ] All major operations captured with typed inputs/outputs
- [ ] **Data flows** (`flow from X to Y`) between action steps
- [ ] **Control flows** (`first X then Y`) for sequencing
- [ ] **Error flows** for error handling paths
- [ ] Entity state machines with proper transitions
- [ ] Event handlers with port-based flows (if applicable)
- [ ] Side effects marked clearly
- [ ] Output is limited to `behavior/` directory only

<% if (it.isIterative) { %>
### File Selection Priority for Behavior Analysis

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Service files (`*.service.ts`, `*.service.js`)
2. Controller files (`*.controller.ts`, `*.handler.ts`)
3. Route files (`*.routes.ts`, `routes/*.ts`)
4. Use case files (`*.usecase.ts`, `usecases/*.ts`)
5. Event handlers (`*.handler.ts`, `handlers/*.ts`)
6. Middleware files (`*.middleware.ts`, `middleware/*.ts`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
