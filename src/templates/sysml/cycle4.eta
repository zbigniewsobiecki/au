## Task: Behavior & Logic

**Goal**: Capture how the system processes requests and manages state

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
**Ports**: <%= Object.entries(it.metadata.ports || {}).filter(([,v]) => v).map(([k]) => k).join(", ") || "none" %>
<% } %>

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**IMPORTANT**: Generate SysML behavior definitions from ALL files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `// Source: <filepath>` comments to track which files have been covered.
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Find behavior sources**:
   - Controllers/handlers
   - Service methods
   - Use cases
   - Event handlers
   - CLI commands

2. **Map operations**:
   - Input/output for each operation
   - Steps in the flow
   - Side effects

3. **Identify state machines**:
   - Entity lifecycle states
   - Workflow states
   - Session states

4. **Document event flows**:
   - Events emitted
   - Events handled
   - Pub/sub patterns

5. **Generate SysML**:

   **behavior/_index.sysml** - Update overview:
   ```sysml
   package SystemBehavior {
       import SysMLPrimitives::*;
       import DataModel::*;
       import SystemArchitecture::*;

       doc /**System behavioral model */
   }
   ```

   **behavior/operations.sysml** - Add operations (use `SystemBehavior` namespace):
   ```sysml
   package SystemBehavior {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**System operations/actions */

       // User registration operation
       action def RegisterUser {
           doc /**Register a new user account.
           Steps: validateInput -> checkExistingEmail -> hashPassword -> createUser -> generateTokens */

           in request : CreateUserRequest;
           out response : UserResponse;
           out error : ErrorResponse [0..1];

           action validateInput {
               doc /**Validate email format and password strength */
           }

           action checkExistingEmail {
               doc /**Verify email is not already registered */
           }

           action hashPassword {
               doc /**Securely hash the password */
           }

           action createUser {
               doc /**Persist user to database */
           }

           action generateTokens {
               doc /**Generate JWT access and refresh tokens */
           }
       }

       // Authentication operation
       action def Login {
           doc /**Authenticate user and issue tokens.
           Steps: verifyCredentials -> checkAccountStatus -> issueTokens */

           in credentials : LoginRequest;
           out tokens : TokenResponse;
           out error : ErrorResponse [0..1];

           action verifyCredentials;
           action checkAccountStatus;
           action issueTokens;
       }
   }
   ```

   **behavior/states.sysml** - Add state machines:
   ```sysml
   package EntityStateMachines {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**Entity state machines */

       // Order lifecycle
       state def OrderLifecycle {
           doc /**Order processing state machine */

           state Pending {
               doc /**Order created, awaiting processing */
           }

           state Processing {
               doc /**Order is being prepared */
           }

           state Shipped {
               doc /**Order has been shipped */
           }

           state Delivered {
               doc /**Order delivered to customer */
           }

           state Cancelled {
               doc /**Order was cancelled */
           }

           // Transitions
           transition first Pending then Processing;
           transition first Processing then Shipped;
           transition first Shipped then Delivered;
           transition first Pending then Cancelled;
           transition first Processing then Cancelled;
       }

       // User session state
       state def SessionState {
           state Anonymous;
           state Authenticated;
           state Expired;

           transition first Anonymous then Authenticated;
           transition first Authenticated then Anonymous;
           transition first Authenticated then Expired;
           transition first Expired then Authenticated;
       }
   }
   ```

   **behavior/handlers.sysml** - Add event handlers:
   ```sysml
   package EventHandlers {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /**Event handlers */

       action def OnUserCreated {
           doc /**Handle user creation event */

           in event : UserCreatedEvent;

           action sendWelcomeEmail;
           action initializeUserSettings;
           action notifyAnalytics;

           // These can run in parallel
       }

       action def OnOrderShipped {
           doc /**Handle order shipped event */

           in event : OrderShippedEvent;

           action sendShippingNotification;
           action updateInventory;
       }
   }
   ```

### ID Sequencing Convention

**CRITICAL**: Before assigning any ID, use `SysMLRead` to check existing files and find the highest ID in use.

| Category | Format | Example |
|----------|--------|---------|
| Operations | OP-001, OP-002... | OP-001, OP-002 |
| State machines | SM-001, SM-002... | SM-001, SM-002 |
| Events | EV-001, EV-002... | EV-001, EV-002 |

- IDs must be sequential with no gaps
- Always continue from the highest existing ID
- Never reuse or reassign IDs

### Behavior Sources by Framework

| Framework | Behavior Sources |
|-----------|-----------------|
| Express/Fastify | Route handlers, middleware |
| NestJS | Controllers, services, guards |
| FastAPI | Route functions, dependencies |
| Django | Views, signals |
| Spring | Controllers, services |
| Gin/Echo | Handlers, middleware |

### What to Look For

- **Happy path**: Normal operation flow
- **Error handling**: How errors are caught and handled
- **Side effects**: External calls (email, payment, etc.)
- **Transactions**: Database transaction boundaries
- **Middleware**: Pre/post processing

### Deliverables

Write ONLY these files:
- `behavior/_index.sysml` - Behavior overview
- `behavior/operations.sysml` - System operations/actions with flows
- `behavior/states.sysml` - Entity state machines
- `behavior/handlers.sysml` - Event handlers (optional, if event-driven)

**IMPORTANT**: Do NOT write to context/, structure/, data/, verification/, or analysis/ directories.
This cycle focuses ONLY on behavioral modeling. Verification and analysis will be handled in later cycles.

### Success Criteria

- [ ] All major operations captured
- [ ] Operation flows documented with steps
- [ ] Entity state machines identified
- [ ] Event handlers documented (if applicable)
- [ ] Side effects marked clearly
- [ ] Output is limited to `behavior/` directory only

<% if (it.isIterative) { %>
### File Selection Priority for Behavior Analysis

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Service files (`*.service.ts`, `*.service.js`)
2. Controller files (`*.controller.ts`, `*.handler.ts`)
3. Route files (`*.routes.ts`, `routes/*.ts`)
4. Use case files (`*.usecase.ts`, `usecases/*.ts`)
5. Event handlers (`*.handler.ts`, `handlers/*.ts`)
6. Middleware files (`*.middleware.ts`, `middleware/*.ts`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
