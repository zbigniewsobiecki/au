## Task: Analysis & Properties

**Goal**: Define non-functional characteristics and analysis cases

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
**Architecture**: <%= it.metadata.architectureStyle %>
<% } %>

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Analyze performance patterns**:
   - Caching (Redis, in-memory)
   - Rate limiting
   - Async processing
   - Connection pooling

2. **Analyze reliability patterns**:
   - Retry logic
   - Circuit breakers
   - Graceful degradation
   - Health checks

3. **Analyze security controls**:
   - Authentication method
   - Authorization model
   - Input validation
   - Encryption

4. **Analyze observability**:
   - Logging
   - Metrics
   - Tracing
   - Alerting

5. **Map access control to endpoints/operations**:
   - Find how this codebase enforces authorization (varies by project)
   - Map which roles/permissions can access which endpoints
   - Identify public endpoints (no auth required)
   - Document admin-only operations

   **Output file**: `analysis/access-control.sysml`
   ```sysml
   package AccessControlAnalysis {
       import SysMLPrimitives::*;
       import SystemBehavior::*;

       doc /*Access control mapping - which roles can perform which operations */

       // Discovered roles (based on what's in the codebase)
       enum def SystemRoles {
           Admin;
           User;
           Salesperson;
       }

       // Access policy mapping
       part def EndpointAccessPolicy {
           doc /*Maps endpoints to required authentication/authorization */

           // Public endpoints (no auth required)
           part publicEndpoints {
               doc /*Accessible without authentication */
               // e.g., Login, HealthCheck, public pages
           }

           // Authenticated (any logged-in user)
           part authenticatedEndpoints {
               doc /*Requires authentication but no specific role */
           }

           // Admin-only
           part adminOnlyEndpoints {
               doc /*Requires admin role */
               // e.g., user registration, system config
           }

           // Role-specific
           part salespersonEndpoints {
               doc /*Requires salesperson or higher role */
           }
       }

       // Concrete access mappings
       allocation def RoutePermissions {
           doc /*Maps specific operations to access requirements */
           // Public
           allocate Login to publicEndpoints;
           allocate HealthCheck to publicEndpoints;

           // Admin only
           allocate Register to adminOnlyEndpoints;  // Admin creates users

           // Authenticated
           allocate ListVehicles to authenticatedEndpoints;
           allocate CreateVehicle to authenticatedEndpoints;
           allocate CreateSale to authenticatedEndpoints;
       }
   }
   ```

   Search for authorization patterns specific to this codebase:
   - Route guards/middleware (e.g., `requireAuth`, `requireRole`)
   - Role decorators (@Roles, @RequirePermission, etc.)
   - Conditional checks (if user.role === 'ADMIN')
   - Policy classes

6. **Generate SysML**:

   **analysis/_index.sysml** - Update overview (MUST import all sibling packages):
   ```sysml
   package Analysis {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import PerformanceAnalysis::*;
       import ReliabilityAnalysis::*;
       import SecurityAnalysis::*;
       import ObservabilityAnalysis::*;

       doc /*System analysis and quality attributes */
   }
   ```

   **⚠️ INDEX FILE WARNING**: The `_index.sysml` files accumulate imports over time.
   If modifying an existing index:
   1. First use `SysMLRead(path="analysis/_index.sysml")` to see current imports
   2. Then use SysMLWrite with `element` + `at` to upsert imports
   3. Do NOT assume the file matches these examples - it may already have other imports

   **analysis/performance.sysml** - Add performance analysis:
   ```sysml
   package PerformanceAnalysis {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;

       doc /*Performance characteristics */

       analysis def PerformanceProfile {
           subject system : System;

           // Discovered patterns
           attribute hasCaching : Boolean = {true|false};
           attribute cacheProvider : String = "{redis|memcached|in-memory|none}";

           attribute hasRateLimiting : Boolean = {true|false};
           attribute rateLimitStrategy : String = "{token-bucket|sliding-window|fixed-window|none}";

           attribute hasAsyncProcessing : Boolean = {true|false};
           attribute asyncMechanism : String = "{queue|worker|event-loop|none}";

           attribute hasConnectionPooling : Boolean = {true|false};
           attribute pooledConnections : String [0..*];

           attribute hasCompression : Boolean = {true|false};
           attribute hasCDN : Boolean = {true|false};

           results {
               attribute estimatedLatencyMs : Real;
               attribute estimatedThroughput : Real;
               attribute scalabilityNotes : String;
           }
       }

       // Caching analysis
       analysis def CachingAnalysis {
           attribute cacheLocations : String [0..*];
           attribute cacheStrategies : String [0..*];
           attribute ttlPatterns : String [0..*];

           results {
               attribute cacheHitRatioEstimate : Real;
           }
       }
   }
   ```

   **analysis/reliability.sysml** - Add reliability analysis:
   ```sysml
   package ReliabilityAnalysis {
       import SysMLPrimitives::*;

       doc /*Reliability patterns */

       analysis def ReliabilityProfile {
           // Retry patterns
           attribute hasRetries : Boolean = {true|false};
           attribute retryStrategy : String = "{exponential-backoff|fixed|none}";
           attribute maxRetries : Integer [0..1];

           // Circuit breaker
           attribute hasCircuitBreaker : Boolean = {true|false};
           attribute circuitBreakerThreshold : Integer [0..1];

           // Graceful degradation
           attribute hasGracefulDegradation : Boolean = {true|false};
           attribute fallbackStrategies : String [0..*];

           // Health checks
           attribute hasHealthChecks : Boolean = {true|false};
           attribute healthEndpoints : String [0..*];

           // Timeouts
           attribute hasTimeouts : Boolean = {true|false};
           attribute defaultTimeoutMs : Integer [0..1];

           results {
               attribute failureHandling : String;
               attribute recoveryStrategy : String;
               attribute estimatedAvailability : String;
           }
       }

       // Error handling analysis
       analysis def ErrorHandlingAnalysis {
           attribute errorBoundaries : String [0..*];
           attribute globalErrorHandler : Boolean = {true|false};
           attribute errorLogging : Boolean = {true|false};
           attribute errorReporting : String [0..1];

           results {
               attribute errorRecoveryNotes : String;
           }
       }
   }
   ```

   **analysis/security.sysml** - Add security analysis:
   ```sysml
   package SecurityAnalysis {
       import SysMLPrimitives::*;

       doc /*Security posture */

       analysis def SecurityProfile {
           // Authentication
           attribute authenticationMethod : String = "{jwt|session|oauth|api-key|none}";
           attribute authProvider : String [0..1];
           attribute mfaSupported : Boolean = {true|false};

           // Authorization
           attribute authorizationModel : String = "{rbac|abac|acl|none}";
           attribute permissionGranularity : String = "{coarse|fine|none}";

           // Input validation
           attribute hasInputValidation : Boolean = {true|false};
           attribute validationLibrary : String [0..1];
           attribute sanitizesOutput : Boolean = {true|false};

           // Encryption
           attribute hasEncryptionAtRest : Boolean = {true|false};
           attribute hasEncryptionInTransit : Boolean = {true|false};
           attribute encryptionAlgorithms : String [0..*];

           // Secrets management
           attribute secretsManagement : String = "{env|vault|aws-secrets|none}";

           // Rate limiting (security aspect)
           attribute hasSecurityRateLimiting : Boolean = {true|false};
           attribute bruteForceProtection : Boolean = {true|false};

           // CORS
           attribute hasCORS : Boolean = {true|false};
           attribute corsPolicy : String [0..1];

           results {
               attribute securityPosture : String;
               attribute identifiedRisks : String [0..*];
               attribute recommendations : String [0..*];
           }
       }

       // Threat analysis
       package ThreatAnalysis {
           doc /*Common threats and mitigations */

           constraint def SQLInjectionMitigation {
               doc /*Use parameterized queries */
           }

           constraint def XSSMitigation {
               doc /*Sanitize user input, use CSP */
           }

           constraint def CSRFMitigation {
               doc /*Use CSRF tokens */
           }
       }
   }
   ```

   **analysis/observability.sysml** - Add observability analysis:
   ```sysml
   package ObservabilityAnalysis {
       import SysMLPrimitives::*;

       doc /*Observability and monitoring */

       analysis def ObservabilityProfile {
           // Logging
           attribute hasStructuredLogging : Boolean = {true|false};
           attribute loggingLibrary : String [0..1];
           attribute logLevels : String [0..*];
           attribute logDestinations : String [0..*];

           // Metrics
           attribute hasMetrics : Boolean = {true|false};
           attribute metricsLibrary : String [0..1];
           attribute metricsExporter : String [0..1];
           attribute customMetrics : String [0..*];

           // Tracing
           attribute hasDistributedTracing : Boolean = {true|false};
           attribute tracingLibrary : String [0..1];
           attribute tracingBackend : String [0..1];

           // Alerting
           attribute hasAlerting : Boolean = {true|false};
           attribute alertingPlatform : String [0..1];

           results {
               attribute observabilityMaturity : String;
               attribute monitoringGaps : String [0..*];
           }
       }
   }
   ```

   **analysis/allocations.sysml** - E2E Step 3: Bind behaviors to implementing modules:
   ```sysml
   package BehaviorAllocations {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;
       import SystemBehavior::*;

       doc /*E2E Step 3: Allocation (Binding).
            Maps action defs (Step 1) to implementing modules.
            Step 1 sources: behavior/operations.sysml (action defs with flow from / first..then).
            Step 2 sources: structure/interfaces.sysml (interface/connection defs with item flows). */

       // Allocation type for operation-to-module mapping
       allocation def OperationAllocation :> BehaviorToModule {
           doc /*Maps operations to their implementing modules */
       }

       // ── Coarse-grained allocations (whole action → module) ──
       allocate RegisterUser to UserModule;
       allocate Login to AuthModule;
       allocate ProcessOrder to OrderModule;
       allocate ProcessPayment to PaymentModule;

       // ── Granular E2E allocations (sub-action → module) ──
       // Bind each step of LoginE2E (Step 1) to the module that implements it
       allocate LoginE2E.validate to ApiGateway;        // input validation at gateway
       allocate LoginE2E.authenticate to AuthModule;    // credential check in auth module
       allocate LoginE2E.issueTokens to AuthModule;     // token generation in auth module

       // Critical path allocations with metadata
       @CriticalPath;
       allocate Checkout to CheckoutModule;
   }
   ```

   **analysis/constraints.sysml** - Performance constraints and assertions:
   ```sysml
   package PerformanceConstraints {
       import SysMLPrimitives::*;
       import SystemArchitecture::*;

       doc /*Performance constraints with expressions */

       // Response time constraint
       constraint def ResponseTimeLimit {
           doc /*API response must be within limit */
           in actual : Real;
           in limit : Real = 200;
           actual <= limit
       }

       // Throughput constraint
       constraint def ThroughputMinimum {
           doc /*System must handle minimum requests per second */
           in actual : Real;
           in minimum : Real = 100;
           actual >= minimum
       }

       // Availability constraint
       constraint def AvailabilityTarget {
           doc /*System uptime must meet SLA */
           in uptime : Real;
           in target : Real = 99.9;
           uptime >= target
       }

       // Apply constraints with assert
       assert constraint apiResponseTime : ResponseTimeLimit {
           in actual = system.measuredLatency;
           in limit = 200;
       }

       assert constraint systemThroughput : ThroughputMinimum {
           in actual = system.requestsPerSecond;
           in minimum = 1000;
       }

       assert constraint systemAvailability : AvailabilityTarget {
           in uptime = system.uptimePercent;
           in target = 99.9;
       }
   }
   ```

### Pattern Detection Guide

| Pattern | Look For |
|---------|----------|
| Caching | Redis client, `cache`, `ttl`, `@Cacheable` |
| Rate Limiting | `rateLimit`, `throttle`, `limiter` |
| Retry | `retry`, `backoff`, `attempt`, `maxRetries` |
| Circuit Breaker | `circuitBreaker`, `opossum`, `resilience` |
| Auth | `passport`, `jwt`, `oauth`, `auth`, `bearer` |
| Validation | `zod`, `joi`, `yup`, `class-validator` |
| Logging | `winston`, `pino`, `bunyan`, `logger` |
| Metrics | `prometheus`, `statsd`, `metrics`, `gauge` |
| Tracing | `opentelemetry`, `jaeger`, `zipkin`, `trace` |
| Role Guards | `@Roles`, `requireRole`, `checkRole`, `isAdmin` |
| Route Protection | `authMiddleware`, `requireAuth`, `isAuthenticated` |
| Public Routes | routes without auth middleware, `/health`, `/login` |

### What to Look For

- **Configuration files**: Often reveal infrastructure choices
- **Middleware stack**: Shows cross-cutting concerns
- **Environment variables**: Security and config patterns
- **Dependencies**: Libraries reveal patterns used

### Deliverables

Write ONLY these files:
- `analysis/_index.sysml` - Analysis overview
- `analysis/performance.sysml` - Performance characteristics and patterns
- `analysis/reliability.sysml` - Reliability patterns and error handling
- `analysis/security.sysml` - Security controls and posture
- `analysis/observability.sysml` - Logging, metrics, tracing setup
- `analysis/allocations.sysml` - Behavior-to-module mappings
- `analysis/constraints.sysml` - Performance constraints with expressions
- `analysis/access-control.sysml` - Role-to-operation permission mapping

This is the final cycle. You may also update the master `_model.sysml` index if needed.

### Allocation and Constraint Patterns

**Allocation Pattern** - Map behaviors to implementing modules:
```sysml
// Simple allocation
allocate {Operation} to {Module};

// With metadata
@CriticalPath
allocate {CriticalOperation} to {Module};

// Typed allocation
allocation {name} : OperationAllocation
    allocate {Operation} to {Module};
```

**Granular E2E Allocation Pattern** - Bind sub-actions to modules (E2E Step 3):
```sysml
// Step 3: Bind each sub-action from an E2E action def to the module that implements it
// Source: action def LoginE2E { action validate; action authenticate; action issueTokens; }
allocate LoginE2E.validate to ApiGateway;
allocate LoginE2E.authenticate to AuthModule;
allocate LoginE2E.issueTokens to AuthModule;
```

**Constraint Pattern** - Define with expressions:
```sysml
constraint def {ConstraintName} {
    in {param} : {Type};
    in {limit} : {Type} = {default};
    {param} <= {limit}  // or >=, ==, and, or
}
```

**Assert Pattern** - Apply constraints:
```sysml
assert constraint {name} : {ConstraintDef} {
    in {param} = {actualValue};
    in {limit} = {targetValue};
}
```

**Metadata Pattern** - Annotate critical elements:
```sysml
@CriticalPath
action def ProcessPayment { /* ... */ }

@SecurityCritical
part def AuthModule { /* ... */ }

@PerformanceSensitive
action def SearchProducts { /* ... */ }
```

### Success Criteria

- [ ] Performance patterns documented
- [ ] Reliability patterns identified
- [ ] Security controls analyzed
- [ ] Observability setup documented
- [ ] **Allocations** mapping operations to modules
- [ ] **E2E allocations** bind sub-actions to modules (`allocate ActionDef.subAction to Module`)
- [ ] **Constraints** with actual expressions (not just doc placeholders)
- [ ] **Metadata annotations** for critical paths
- [ ] **Access control mapping** in `analysis/access-control.sysml`
- [ ] **Public endpoints** identified (no auth required)
- [ ] **Admin-only operations** documented (role-based restrictions)
- [ ] **Route-to-role mapping** for endpoints with specific role requirements
- [ ] Recommendations provided for gaps
- [ ] Output is limited to `analysis/` directory (and optionally `_model.sysml`)

<% if (it.isIterative) { %>
### File Selection Priority for Analysis

When selecting next files with `FileViewerNextFileSet` (returns contents directly), prioritize:
1. Config files (`config.ts`, `*.config.ts`, `*.config.js`)
2. Middleware stack (`middleware/*.ts`, `*.middleware.ts`)
3. Auth/Security (`auth/*.ts`, `guards/*.ts`, `*.guard.ts`)
4. Logging/Monitoring (`logger.ts`, `metrics.ts`, `tracing.ts`)
5. Error handling (`*.filter.ts`, `error-handler.ts`)
6. Infrastructure (`docker-compose.yml`, `*.yaml`, `*.yml`)

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
