## Task: Data & Types

**Goal**: Extract all data structures and their constraints

### Project Context

<% if (it.metadata) { %>
**Language**: <%= it.metadata.primaryLanguage %>
**Framework**: <%= it.metadata.framework || "none" %>
<% } %>

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
### SOURCE FILES TO COVER (from Cycle 0 Manifest)

**CRITICAL**: You MUST extract data models from ALL files matching these patterns:

<% for (const pattern of it.sourceFiles) { %>
- `<%= pattern %>`
<% } %>

Include `@SourceFile { :>> path = "<filepath>"; }` metadata before each definition to track coverage.
Before finishing, verify you have covered ALL matching files.
<% } %>

### PRIORITY: Schema File Extraction

**CRITICAL**: If schema files (`.prisma`, `.graphql`, `.proto`, `.sql`) are present, they are the **source of truth** for the data model and MUST be fully processed:

#### Prisma Schema (`.prisma`)
If a Prisma schema is present:
1. **Extract ALL models** - every `model` block becomes an `item def`
2. **Extract ALL enums** - every `enum` block becomes an `enum def`
3. **Capture relationships** - `@relation` annotations define associations
4. **Note constraints** - `@unique`, `@@unique`, `@@index` become SysML constraints
5. **Map field types** - `String`, `Int`, `DateTime`, etc. to SysML types

**IMPORTANT**: A typical Prisma schema has 30+ models and 20+ enums. Process the ENTIRE schema - do NOT stop early. Every model and enum MUST appear in the output.

#### GraphQL Schema (`.graphql`, `.gql`)
If a GraphQL schema is present:
1. Extract ALL `type` definitions as `item def`
2. Extract ALL `enum` definitions as `enum def`
3. Extract ALL `input` definitions as request DTOs
4. Capture relationships from field types

#### Protobuf (`.proto`)
If Protobuf files are present:
1. Extract ALL `message` definitions as `item def`
2. Extract ALL `enum` definitions as `enum def`
3. Capture nested types and relationships

### Files to Analyze

<% if (it.files && it.files.length > 0) { %>
<% for (const file of it.files) { %>
- `<%= file %>`
<% } %>
<% } else { %>
*Use FileDiscover to find relevant files*
<% } %>

### Your Tasks

1. **Find type definitions**:
   - TypeScript: `.d.ts`, `types.ts`, `interfaces/`
   - Python: Type hints, `@dataclass`, Pydantic models
   - Go: Struct definitions
   - Rust: Struct, enum definitions
   - GraphQL/Protobuf schemas

2. **Extract domain entities**:
   - Database models/entities
   - Core business objects
   - Value objects

3. **Extract DTOs**:
   - API request/response shapes
   - Input/output validation schemas

4. **Find enumerations**:
   - Status types
   - Category/type enums

5. **Discover constraints**:
   - Validation rules
   - Business invariants

6. **Discover business validation rules**:
   - Look for how this codebase validates data (the approach varies by project)
   - Find field-level constraints (required, length, format, patterns)
   - Find cross-field constraints (field A depends on field B)
   - Find uniqueness rules (fields that must be unique like VIN, email, etc.)
   - Find validation libraries in use (zod, joi, yup, class-validator, pydantic, etc.)

   **Output file**: `data/constraints.sysml`
   ```sysml
   package DataConstraints {
       import SysMLPrimitives::*;

       doc /*Business validation rules discovered from source */

       // Uniqueness constraints
       constraint def VinUniqueness :> UniqueConstraint {
           doc /*Vehicle VIN must be unique - enforced in VehicleService.create() */
       }

       constraint def EmailUniqueness :> UniqueConstraint {
           doc /*User email must be unique across all users */
       }

       // Field validation - standalone constraint with expression
       constraint def VinFormat {
           doc /*VIN must be exactly 17 characters */
           in vin : String;
           length(vin) == 17
       }

       // Cross-field validation
       constraint def DateRangeValid {
           doc /*End date must be after start date */
       }
   }
   ```

   Search for validation patterns specific to this codebase - don't assume any particular library.

7. **Generate SysML**:

   **data/_index.sysml** - Update overview (MUST import all sibling packages):
   ```sysml
   package DataModel {
       import SysMLPrimitives::*;
       // CRITICAL: Import all sibling packages to avoid orphaned files
       import DomainEntities::*;
       import DataTransferObjects::*;
       import DomainEnums::*;

       doc /*Data structures discovered from {sources} */
   }
   ```

   **data/entities.sysml** - Add domain entities with specialization hierarchy:
   ```sysml
   package DomainEntities {
       import SysMLPrimitives::*;
       import DataModel::*;

       doc /*Core domain entities using specialization hierarchy */

       // Base entity is defined in DataModel - specialize with :>
       @SourceFile { :>> path = "src/models/user.ts"; }
       item def User :> BaseEntity {
           attribute email : String;
           attribute name : String;
           attribute role : UserRole;
           attribute status : UserStatus;
       }

       // Further specialization
       @SourceFile { :>> path = "src/models/admin.ts"; }
       item def AdminUser :> User {
           redefines role : UserRole = UserRole::Admin;
           attribute permissions : String [0..*];
           attribute department : String;
       }

       @SourceFile { :>> path = "prisma/schema.prisma"; }
       item def Order :> BaseEntity {
           attribute userId : Identifier;
           attribute total : Real;
           attribute status : OrderStatus;
           attribute items : OrderItem [1..*];
       }

       @SourceFile { :>> path = "prisma/schema.prisma"; }
       item def OrderItem {
           attribute productId : Identifier;
           attribute quantity : Integer;
           attribute unitPrice : Real;
       }

       // Relationships between entities using connection
       connection def UserOrders {
           doc /*User has many orders */
           end user : User [1];
           end orders : Order [0..*];
       }

       connection def OrderItems {
           doc /*Order contains line items */
           end order : Order [1];
           end items : OrderItem [1..*];
       }
   }
   ```

   **IMPORTANT**: Include `@SourceFile { :>> path = "<filepath>"; }` metadata before each definition to track where each entity came from. This helps with verification and traceability.

   **data/dtos.sysml** - Add DTOs:
   ```sysml
   package DataTransferObjects {
       import SysMLPrimitives::*;
       import DomainEntities::*;

       doc /*API request/response structures */

       item def CreateUserRequest {
           @required;
           attribute email : String;
           attribute name : String;
           attribute password : String;
       }

       item def UserResponse {
           attribute id : Identifier;
           attribute email : String;
           attribute name : String;
       }
   }
   ```

   **data/enums.sysml** - Add enumerations:
   ```sysml
   package DomainEnums {
       import SysMLPrimitives::*;

       doc /*Domain enumerations */

       enum def UserStatus {
           Active;
           Inactive;
           Suspended;
           Deleted;
       }

       enum def OrderStatus {
           Pending;
           Processing;
           Shipped;
           Delivered;
           Cancelled;
       }
   }
   ```

   **data/events.sysml** - Add domain events (if event-driven):
   ```sysml
   package DomainEvents {
       import SysMLPrimitives::*;
       import DomainEntities::*;

       doc /*Domain events */

       event def UserCreated {
           attribute timestamp : DateTime;
           attribute userId : Identifier;
           attribute email : String;
       }
   }
   ```

### ID Sequencing Convention

**CRITICAL**: Before assigning any ID, use `SysMLRead` to check existing files and find the highest ID in use.

| Category | Format | Example |
|----------|--------|---------|
| Entity constraints | EC-001, EC-002... | EC-001, EC-002 |
| Data types | DT-001, DT-002... | DT-001, DT-002 |

- IDs must be sequential with no gaps
- Always continue from the highest existing ID
- Never reuse or reassign IDs

### Reserved Keywords - CRITICAL

**NEVER use these as attribute names** (they are SysML keywords and will cause parse errors):

| Keyword | Use Instead |
|---------|-------------|
| `state` | `stateValue`, `status`, `stateProvince` |
| `action` | `actionType`, `actionName` |
| `flow` | `flowType`, `dataFlow` |
| `connection` | `connectionType`, `conn` |
| `transition` | `transitionType`, `trans` |
| `port` | `portNumber`, `portValue` |
| `item` | `itemValue`, `itemType` |
| `part` | `partNumber`, `partValue` |
| `package` | `packageName`, `pkg` |
| `import` | `importType`, `importPath` |
| `in` | `input`, `inbound` |
| `out` | `output`, `outbound` |
| `end` | `endDate`, `ending` |

If a source field is named `state`, rename to `stateProvince` or `status` in SysML.

### Specialization Patterns

**Entity Specialization** - Use `:>` to inherit from base types:
```sysml
// BaseEntity extends Item for standard library compatibility (defined in DataModel)
// item def BaseEntity :> Item { id, createdAt, updatedAt }

// All domain entities inherit from BaseEntity
item def {Entity} :> BaseEntity {
    // BaseEntity provides: id, createdAt, updatedAt (and Item inheritance)
    attribute {field} : {Type};
}

// Further specialization for subtypes
item def {SpecializedEntity} :> {Entity} {
    redefines {field} : {Type} = {value};  // Override inherited field
    attribute {newField} : {Type};
}
```

**Relationship Pattern** - Model relationships between entities using connection:
```sysml
// One-to-many relationship
connection def {EntityA}{EntityB}s {
    doc /*{EntityA} has many {EntityB}s */
    end {entityA} : {EntityA} [1];
    end {entityB}s : {EntityB} [0..*];
}

// One-to-one relationship
connection def {EntityA}{EntityB} {
    end {entityA} : {EntityA} [1];
    end {entityB} : {EntityB} [0..1];
}

// Many-to-many relationship
connection def {EntityA}{EntityB}Mapping {
    end {entityA}s : {EntityA} [0..*];
    end {entityB}s : {EntityB} [0..*];
}
```

**DTO Specialization** - Request/Response patterns:
```sysml
// Base DTO from DataModel
item def {Create}{Entity}Request :> BaseDTO {
    // Only fields needed for creation
    attribute {field} : {Type};
}

item def {Entity}Response :> BaseDTO {
    // Full entity representation for API responses
    attribute id : Identifier;
    attribute {field} : {Type};
}
```

**Event Specialization** - Domain event patterns:
```sysml
// All events inherit from BaseDomainEvent
item def {Entity}Created :> BaseDomainEvent {
    // BaseDomainEvent provides: eventId, timestamp, eventType
    attribute {entity}Id : Identifier;
    attribute {field} : {Type};
}
```

### Type Sources by Language

| Language | Type Sources |
|----------|--------------|
| TypeScript | `.d.ts`, `types.ts`, interfaces, type aliases |
| Python | Type hints, `@dataclass`, Pydantic, SQLAlchemy models |
| Go | Struct definitions, interface definitions |
| Rust | Struct, enum, trait definitions |
| Java | Class definitions, records |
| C# | Class, record, struct definitions |

### What to Look For

- **Required fields**: Which fields are mandatory
- **Optional fields**: Which can be null/undefined
- **Validation rules**: Email format, string length, ranges
- **Relationships**: One-to-many, many-to-many
- **Computed fields**: Derived from other fields
- **Service-layer validation**: Uniqueness checks, business rules in create/update methods
- **Decorator validation**: @IsEmail, @MinLength, @Matches patterns
- **Schema validation**: zod schemas, joi schemas, pydantic validators

### Deliverables

Write ONLY these files:
- `data/_index.sysml` - Data model overview
- `data/entities.sysml` - Domain entities (from Prisma models, GraphQL types, etc.)
- `data/enums.sysml` - Enumerations (from Prisma enums, GraphQL enums, etc.)
- `data/dtos.sysml` - Data transfer objects (optional, for API request/response shapes)
- `data/events.sysml` - Domain events (optional, if event-driven)
- `data/constraints.sysml` - Business validation rules and constraints (uniqueness, format, cross-field)

**IMPORTANT**: Do NOT write to context/, structure/, behavior/, verification/, or analysis/ directories.
This cycle focuses ONLY on data model extraction. Behaviors, verification, etc. will be handled in later cycles.

### Success Criteria

<% if (it.sourceFiles && it.sourceFiles.length > 0) { %>
**SOURCE FILE COVERAGE VERIFICATION**:
- [ ] All files matching source patterns have been processed
- [ ] Each SysML definition includes `@SourceFile { :>> path = "<filepath>"; }` metadata
- [ ] No source files are missing from coverage
<% } %>

- [ ] **ALL schema entities captured** (if Prisma: every `model`; if GraphQL: every `type`)
- [ ] **ALL schema enums captured** (if Prisma: every `enum`; if GraphQL: every `enum`)
- [ ] All domain entities captured with **specialization** (`:> BaseEntity`)
- [ ] All DTOs (request/response) captured with **specialization** (`:> BaseDTO`)
- [ ] All enumerations captured
- [ ] **Relationships** between entities documented (`connection def`)
- [ ] Validation constraints extracted (`@unique`, `@@unique`, `@@index`)
- [ ] **Business constraints** documented in `data/constraints.sysml` (uniqueness rules, format validations)
- [ ] **Service-layer validation** captured (uniqueness checks in create/update methods)
- [ ] Events captured with **specialization** (`:> BaseDomainEvent`) if event-driven
- [ ] Output is limited to `data/` directory only

**Verification**: Ensure your SysML files include `@SourceFile { :>> path = "<filepath>"; }` metadata for every source file you processed. The validation system will check this metadata against the manifest's sourceFiles patterns.

<% if (it.isIterative) { %>
### File Selection Priority for Data Extraction

When selecting next files with `FileViewerNextFileSet`, prioritize:
1. Schema files (`*.prisma`, `*.graphql`, `*.proto`, `*.sql`)
2. Type definition files (`*.types.ts`, `*.d.ts`, `types/*.ts`)
3. Model files (`*.model.ts`, `models/*.ts`)
4. Entity files (`*.entity.ts`, `entities/*.ts`)
5. DTO files (`*.dto.ts`, `dtos/*.ts`)
6. Interface files (`*.interface.ts`, `interfaces/*.ts`)

**IMPORTANT**: Schema files contain the source of truth for data models. Always process them first and completely.

Select 3-8 files per turn. Process ALL <%= it.totalCount %> files before completing.
<% } %>
